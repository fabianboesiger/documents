domain $Math {
  
  function $sign($a: Int): Int
  
  function $div($a: Int, $b: Int, $r: Int): Int
  
  function $mod($a: Int, $b: Int, $r: Int): Int
  
  function $pow($a: Int, $b: Int): Int
  
  function $sqrt($a: Int): Int
  
  function $floor($a: Int, $s: Int): Int
  
  function $ceil($a: Int, $s: Int): Int
  
  function $shift($a: Int, $s: Int): Int
  
  function $bitwise_not($a: Int): Int
  
  function $bitwise_and($a: Int, $b: Int): Int
  
  function $bitwise_or($a: Int, $b: Int): Int
  
  function $bitwise_xor($a: Int, $b: Int): Int
  
  axiom $sign_ax {
    $sign(0) == 0 && (forall $a: Int :: { $sign($a) } ($a > 0 ==> $sign($a) == 1) && ($a < 0 ==> $sign($a) == -1))
  }
  
  axiom $div_ax {
    (forall $a: Int, $b: Int, $r: Int :: { $div($a, $b, $r) } $div($a, $b, $r) == $a / $b + ($a >= 0 || $a % $b == 0 ? 0 : $sign($b)))
  }
  
  axiom $mod_ax {
    (forall $a: Int, $b: Int, $r: Int :: { $mod($a, $b, $r) } $mod($a, $b, $r) == $a - $div($a, $b, $r) * $b)
  }
  
  axiom $pow0N_ax {
    (forall $a: Int :: { $pow(0, $a) } $a != 0 ==> $pow(0, $a) == 0)
  }
  
  axiom $powN0_ax {
    (forall $a: Int :: { $pow($a, 0) } $a != 0 ==> $pow($a, 0) == 1)
  }
  
  axiom $pow_non_negative_ax {
    (forall $a: Int, $b: Int :: { $pow($a, $b) } $a >= 0 ==> $pow($a, $b) >= 0)
  }
  
  axiom $pow_non_negative_and_non_null_ax {
    (forall $a: Int, $b: Int :: { $pow($a, $b) } $a > 0 && $b >= 0 ==> $pow($a, $b) > 0)
  }
  
  axiom $floor_ax {
    (forall $a: Int, $s: Int :: { $floor($a, $s) } $s > 0 ==> $floor($a, $s) == $div(($a < 0 ? $a - ($s - 1) : $a), $s, 0))
  }
  
  axiom $ceil_ax {
    (forall $a: Int, $s: Int :: { $ceil($a, $s) } $s > 0 ==> $ceil($a, $s) == $div(($a < 0 ? $a : $a + $s - 1), $s, 0))
  }
  
  axiom $shift_ax {
    (forall $a: Int, $s: Int :: { $shift($a, $s) } $shift($a, $s) >= 0)
  }
  
  axiom $bitwise_not_ax {
    (forall $a: Int :: { $bitwise_not($a) } $bitwise_not($a) >= 0)
  }
  
  axiom $bitwise_and_ax {
    (forall $a: Int, $b: Int :: { $bitwise_and($a, $b) } $bitwise_and($a, $b) >= 0)
  }
  
  axiom $bitwise_or_ax {
    (forall $a: Int, $b: Int :: { $bitwise_or($a, $b) } $bitwise_or($a, $b) >= 0)
  }
  
  axiom $bitwise_xor_ax {
    (forall $a: Int, $b: Int :: { $bitwise_xor($a, $b) } $bitwise_xor($a, $b) >= 0)
  }
}

domain $Int {
  
  function $wrap(x: Int): $Int
  
  function $unwrap(x: $Int): Int
  
  function $w_mul(x: $Int, y: $Int): $Int
  
  function $w_mulI(x: $Int, y: $Int): $Int
  
  function $w_mulL(x: $Int, y: $Int): $Int
  
  function $w_abs(x: $Int): Int
  
  function $w_mod($a: $Int, $b: $Int): $Int
  
  function $w_modL($a: $Int, $b: $Int): $Int
  
  function $w_div($a: $Int, $b: $Int): $Int
  
  function $w_div_down($a: $Int, $b: $Int): $Int
  
  function $w_div_nat($a: $Int, $b: $Int): $Int
  
  function $w_div_natL($a: $Int, $b: $Int): $Int
  
  axiom $wrap_ax {
    (forall i: Int :: { $wrap(i) } $unwrap($wrap(i)) == i)
  }
  
  axiom $unwrap_ax {
    (forall i: $Int :: { $wrap($unwrap(i)) } $wrap($unwrap(i)) == i)
  }
  
  axiom $w_abs_ax_1 {
    (forall i: $Int :: { $w_abs(i) } $unwrap(i) < 0 ==> $w_abs(i) == -$unwrap(i))
  }
  
  axiom $w_abs_ax_2 {
    (forall i: $Int :: { $w_abs(i) } $unwrap(i) >= 0 ==> $w_abs(i) == $unwrap(i))
  }
  
  axiom $w_mul_intermediate {
    (forall i: $Int, j: $Int :: { $w_mul(i, j) } $w_mul(i, j) == $w_mulI(i, j))
  }
  
  axiom $w_mul_limited {
    (forall i: $Int, j: $Int :: { $w_mul(i, j) } $w_mul(i, j) == $w_mulL(i, j))
  }
  
  axiom $w_mul_intermediate_to_limited {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $w_mulI(i, j) == $w_mulL(i, j))
  }
  
  axiom $w_mul_commutative {
    (forall i: $Int, j: $Int :: { $w_mul(i, j) } $w_mul(i, j) == $w_mulI(j, i))
  }
  
  axiom $w_mul_associative {
    (forall i: $Int, j: $Int, k: $Int :: { $w_mulI(i, $w_mulI(j, k)) } $w_mulI(i, $w_mulI(j, k)) == $w_mulL($w_mulL(i, j), k))
  }
  
  axiom $w_mul_distributive {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, j),$w_mulI(i, k),$w_mulI(i, l) } $unwrap(j) == $unwrap(k) + $unwrap(l) ==> $w_mulI(i, j) == $wrap($unwrap($w_mulL(i, k)) + $unwrap($w_mulL(i, l))))
  }
  
  axiom $w_mul_basic_sign_1 {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $w_mulI(i, j) == $w_mulL($wrap(-$unwrap(i)), $wrap(-$unwrap(j))))
  }
  
  axiom $w_mul_basic_sign_2 {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $w_mulI(i, j) == $wrap(-$unwrap($w_mulL($wrap(-$unwrap(i)), j))))
  }
  
  axiom $w_mul_basic_zero_1 {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $unwrap(i) == 0 || $unwrap(j) == 0 ==> $unwrap($w_mulI(i, j)) == 0)
  }
  
  axiom $w_mul_basic_zero_2 {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $unwrap(i) > 0 && $unwrap(j) > 0 || $unwrap(i) < 0 && $unwrap(j) < 0 ==> $unwrap($w_mulI(i, j)) > 0)
  }
  
  axiom $w_mul_basic_neutral {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $unwrap(i) == 1 || $unwrap(j) == 0 ==> $w_mulI(i, j) == j)
  }
  
  axiom $w_mul_basic_proportional {
    (forall i: $Int, j: $Int :: { $w_mulI(i, j) } $w_abs($w_mulI(i, j)) >= $w_abs(j) == ($w_abs(i) >= 1 || $unwrap(j) == 0))
  }
  
  axiom $w_mul_order_1 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, $w_mulI(j, l)),$w_mulI(k, l) } $unwrap($w_mulI(i, j)) > $unwrap(k) && $unwrap(l) > 0 ==> $unwrap($w_mulL(i, $w_mulL(j, l))) > $unwrap($w_mulI(k, l)))
  }
  
  axiom $w_mul_order_2 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, $w_mulI(j, l)),$w_mulI(k, l) } $unwrap($w_mulI(i, j)) >= $unwrap(k) && $unwrap(l) > 0 ==> $unwrap($w_mulL(i, $w_mulL(j, l))) >= $unwrap($w_mulI(k, l)))
  }
  
  axiom $w_mul_order_3 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, $w_mulI(j, l)),$w_mulI(k, l) } $unwrap($w_mulI(i, j)) > $unwrap(k) && $unwrap(l) < 0 ==> $unwrap($w_mulI(k, l)) > $unwrap($w_mulL(i, $w_mulL(j, l))))
  }
  
  axiom $w_mul_order_4 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, $w_mulI(j, l)),$w_mulI(k, l) } $unwrap($w_mulI(i, j)) >= $unwrap(k) && $unwrap(l) < 0 ==> $unwrap($w_mulI(k, l)) >= $unwrap($w_mulL(i, $w_mulL(j, l))))
  }
  
  axiom $w_mul_monotonicity_1 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, k),$w_mulI(j, l) } $w_abs(i) <= $w_abs(j) && $w_abs(k) <= $w_abs(l) ==> $w_abs($w_mulI(i, k)) <= $w_abs($w_mulI(j, l)))
  }
  
  axiom $w_mul_monotonicity_2 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, k),$w_mulI(j, l) } $w_abs(i) < $w_abs(j) && ($w_abs(k) <= $w_abs(l) && $unwrap(l) != 0) ==> $w_abs($w_mulI(i, k)) < $w_abs($w_mulI(j, l)))
  }
  
  axiom $w_mul_monotonicity_3 {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mulI(i, k),$w_mulI(j, l) } $w_abs(i) <= $w_abs(j) && ($w_abs(k) < $w_abs(l) && $unwrap(j) != 0) ==> $w_abs($w_mulI(i, k)) < $w_abs($w_mulI(j, l)))
  }
  
  axiom $w_mod_limited {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } $w_mod(i, j) == $w_modL(i, j))
  }
  
  axiom $w_mod_identity {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> i == j || i == $wrap(0) ==> $w_mod(i, j) == $wrap(0))
  }
  
  axiom $w_mod_basic_1 {
    (forall i: $Int, j: $Int, l: $Int :: { $w_mod(i, j),$w_mod(l, j) } j != $wrap(0) ==> $unwrap(i) == $unwrap(l) + $w_abs(j) && ($unwrap(l) >= 0 || $unwrap(i) < 0) ==> $w_mod(i, j) == $w_modL(l, j))
  }
  
  axiom $w_mod_basic_2 {
    (forall i: $Int, j: $Int, l: $Int :: { $w_mod(i, j),$w_mod(l, j) } j != $wrap(0) ==> $unwrap(i) == $unwrap(l) - $w_abs(j) && ($unwrap(l) <= 0 || $unwrap(i) > 0) ==> $w_mod(i, j) == $w_modL(l, j))
  }
  
  axiom $w_mod_basic_3 {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> 0 <= $w_abs(i) && $w_abs(i) < $w_abs(j) ==> $w_mod(i, j) == i)
  }
  
  axiom $w_mod_basic_4 {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> $w_abs($w_mod(i, j)) < $w_abs(j))
  }
  
  axiom $w_mod_sign_1 {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> $sign($unwrap($w_mod(i, j))) == $sign($unwrap(i)) || $sign($unwrap($w_mod(i, j))) == 0)
  }
  
  axiom $w_mod_sign_2 {
    (forall i: $Int, j: $Int, k: $Int :: { $w_mod(i, j),$w_mod(k, j) } j != $wrap(0) ==> $unwrap(i) == -$unwrap(k) ==> $w_mod(i, j) == $wrap(-$unwrap($w_modL(k, j))))
  }
  
  axiom $w_mod_sign_3 {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> $w_mod(i, j) == $w_mod(i, $wrap(-$unwrap(j))))
  }
  
  axiom $w_mod_mod {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> $w_mod(i, j) == $w_modL($w_modL(i, j), j))
  }
  
  axiom $w_mod_decrease {
    (forall i: $Int, j: $Int :: { $w_mod(i, j) } j != $wrap(0) ==> $w_abs($w_mod(i, j)) <= $w_abs(i))
  }
  
  axiom $w_mod_add {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_mod(i, j),$w_mod(k, j),$w_mod(l, j) } j != $wrap(0) ==> $unwrap(i) == $unwrap(k) + $unwrap(l) ==> ($unwrap(i) >= 0 && $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) >= 0 || $unwrap(i) <= 0 && $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) <= 0 ==> $w_abs(j) <= $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) && ($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) < 2 * $w_abs(j) && $w_mod(i, j) == $wrap($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) - $w_abs(j))) || (-$w_abs(j) < $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) && ($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) < $w_abs(j) && $w_mod(i, j) == $wrap($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)))) || -2 * $w_abs(j) < $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) && ($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) <= -$w_abs(j) && $w_mod(i, j) == $wrap($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) + $w_abs(j))))) && ($unwrap(i) > 0 && $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) < 0 || $unwrap(i) < 0 && $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) > 0 ==> 0 < $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) && ($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) < $w_abs(j) && $w_mod(i, j) == $wrap($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) - $w_abs(j))) || -$w_abs(j) < $unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) && ($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) < 0 && $w_mod(i, j) == $wrap($unwrap($w_modL(k, j)) + $unwrap($w_modL(l, j)) + $w_abs(j)))))
  }
  
  axiom $w_mod_mul_basic {
    (forall i: $Int, j: $Int :: { $w_mod($w_mul(i, j), j) } j != $wrap(0) ==> $w_mod($w_mul(i, j), j) == $wrap(0))
  }
  
  axiom $w_mod_mul_mod_noop {
    (forall i: $Int, j: $Int, k: $Int :: { $w_mod($w_mulI(i, k), j) } j != $wrap(0) ==> $w_mod($w_mulI(i, k), j) == $w_modL($w_mulL($w_modL(i, j), k), j) && ($w_mod($w_mulI(i, k), j) == $w_modL($w_mulL(i, $w_modL(k, j)), j) && $w_mod($w_mulI(i, k), j) == $w_modL($w_mulL($w_modL(i, j), $w_modL(k, j)), j)))
  }
  
  axiom $w_mod_mul_vanish {
    (forall i: $Int, j: $Int, k: $Int :: { $w_mod(i, j),$w_mulI(k, j) } j != $wrap(0) ==> $w_mod(i, j) == $w_modL($wrap($unwrap($w_mulL(k, j)) + $unwrap(i)), j))
  }
  
  axiom $w_div_div_down {
    (forall i: $Int, j: $Int :: { $w_div(i, j) } $unwrap(j) != 0 ==> $w_div(i, j) == ($unwrap(i) >= 0 ? $w_div_down(i, j) : $wrap(-$unwrap($w_div_down($wrap(-$unwrap(i)), j)))))
  }
  
  axiom $w_div_down_div_nat {
    (forall i: $Int, j: $Int :: { $w_div_down(i, j) } $w_div_down(i, j) == ($unwrap(j) >= 0 ? $w_div_nat(i, j) : $wrap(-$unwrap($w_div_nat(i, $wrap(-$unwrap(j)))))))
  }
  
  axiom $w_div_nat_limited {
    (forall i: $Int, j: $Int :: { $w_div_nat(i, j) } $w_div_nat(i, j) == $w_div_natL(i, j))
  }
  
  axiom $w_div_nat_neutral {
    (forall i: $Int, j: $Int :: { $w_div_nat(i, j) } $unwrap(j) == 1 || $unwrap(i) == 0 ==> $w_div_nat(i, j) == i)
  }
  
  axiom $w_div_nat_self {
    (forall i: $Int :: { $w_div_nat(i, i) } $unwrap(i) > 0 ==> $w_div_nat(i, i) == $wrap(1))
  }
  
  axiom $w_div_nat_small {
    (forall i: $Int, j: $Int :: { $w_div_nat(i, j) } $unwrap(i) >= 0 && $unwrap(j) > 0 ==> $unwrap(i) < $unwrap(j) == ($w_div_nat(i, j) == $wrap(0)))
  }
  
  axiom $w_div_nat_dividend_add {
    (forall i: $Int, j: $Int, k: $Int, l: $Int :: { $w_div_nat(i, j),$w_div_nat(k, j),$w_div_nat(l, j) } $unwrap(i) >= 0 && ($unwrap(j) > 0 && ($unwrap(k) >= 0 && $unwrap(l) >= 0)) ==> $unwrap(i) == $unwrap(k) + $unwrap(l) ==> 0 <= $unwrap($w_mod(k, j)) + $unwrap($w_mod(l, j)) && ($unwrap($w_mod(k, j)) + $unwrap($w_mod(l, j)) < $unwrap(j) && $w_div_nat(i, j) == $wrap($unwrap($w_div_natL(k, j)) + $unwrap($w_div_natL(l, j)))) || $unwrap(j) <= $unwrap($w_mod(k, j)) + $unwrap($w_mod(l, j)) && ($unwrap($w_mod(k, j)) + $unwrap($w_mod(l, j)) < 2 * $unwrap(j) && $w_div_nat(i, j) == $wrap($unwrap($w_div_natL(k, j)) + $unwrap($w_div_natL(l, j)) + 1)))
  }
  
  axiom $w_div_nat_ordered_by_dividend {
    (forall i: $Int, j: $Int, k: $Int :: { $w_div_nat(i, j),$w_div_nat(k, j) } $unwrap(i) >= 0 && ($unwrap(j) > 0 && $unwrap(k) >= 0) ==> $unwrap(i) <= $unwrap(k) ==> $unwrap($w_div_nat(i, j)) <= $unwrap($w_div_natL(k, j)))
  }
  
  axiom $w_div_nat_ordered_by_divisor {
    (forall i: $Int, j: $Int, k: $Int :: { $w_div_nat(i, j),$w_div_nat(i, k) } $unwrap(i) >= 0 && ($unwrap(j) > 0 && $unwrap(k) > 0) ==> $unwrap(j) <= $unwrap(k) ==> $unwrap($w_div_nat(i, j)) >= $unwrap($w_div_natL(i, k)))
  }
  
  axiom $w_div_nat_decrease {
    (forall i: $Int, j: $Int :: { $w_div_nat(i, j) } $unwrap(i) > 0 && $unwrap(j) > 1 ==> $unwrap($w_div_nat(i, j)) < $unwrap(i))
  }
  
  axiom $w_div_nat_nonincrease {
    (forall i: $Int, j: $Int :: { $w_div_nat(i, j) } $unwrap(i) >= 0 && $unwrap(j) > 0 ==> $unwrap($w_div_nat(i, j)) <= $unwrap(i))
  }
  
  axiom $w_div_mul {
    (forall i: $Int, j: $Int :: { $w_div($w_mulI(i, j), j) } $unwrap(j) != 0 ==> $w_div($w_mulI(i, j), j) == i)
  }
  
  axiom $w_div_sign {
    (forall i: $Int, j: $Int :: { $w_div(i, j) } $unwrap(j) != 0 ==> $sign($unwrap($w_div(i, j))) == $sign($unwrap(i)) * $sign($unwrap(j)) || $sign($unwrap($w_div(i, j))) == 0)
  }
  
  axiom $w_div_mod_mul {
    (forall i: $Int, j: $Int :: { $w_div(i, j),$w_mod(i, j) } $unwrap(j) != 0 ==> $unwrap(i) == $unwrap($w_mulI(j, $w_div(i, j))) + $unwrap($w_mod(i, j)))
  }
}

domain $Array[$E] {
  
  function $array_init($e: $E, $c: Int): Seq[$E]
  
  axiom $array_init_len_ax {
    (forall $e: $E, $c: Int :: { ($array_init($e, $c): Seq[$E]) } |($array_init($e, $c): Seq[$E])| == $c)
  }
  
  axiom $array_init_val_ax {
    (forall $e: $E, $c: Int, $i: Int :: { ($array_init($e, $c): Seq[$E])[$i] } 0 <= $i && $i < $c ==> ($array_init($e, $c): Seq[$E])[$i] == $e)
  }
}

domain $Map[$K, $V] {
  
  function $map_init($v: $V): $Map[$K, $V]
  
  function $map_eq($m: $Map[$K, $V], $n: $Map[$K, $V]): Bool
  
  function $map_get($m: $Map[$K, $V], $k: $K): $V
  
  function $map_set($m: $Map[$K, $V], $k: $K, $v: $V): $Map[$K, $V]
  
  axiom $map_init_ax {
    (forall $v: $V, $k: $K :: { ($map_get(($map_init($v): $Map[$K, $V]), $k): $V) } ($map_get(($map_init($v): $Map[$K, $V]), $k): $V) == $v)
  }
  
  axiom $map_eq_ax {
    (forall $m: $Map[$K, $V], $n: $Map[$K, $V] :: { ($map_eq($m, $n): Bool) } ($map_eq($m, $n): Bool) == ($m == $n) && ($map_eq($m, $n): Bool) == (forall $k: $K :: { ($map_get($m, $k): $V),($map_get($n, $k): $V) } ($map_get($m, $k): $V) == ($map_get($n, $k): $V)))
  }
  
  axiom $map_set_ax {
    (forall $m: $Map[$K, $V], $k: $K, $v: $V, $kk: $K :: { ($map_get(($map_set($m, $k, $v): $Map[$K, $V]), $kk): $V) } ($map_get(($map_set($m, $k, $v): $Map[$K, $V]), $kk): $V) == ($k == $kk ? $v : ($map_get($m, $kk): $V)))
  }
}

domain $MapInt[$K] {
  
  function $map_sum($m: $Map[$K, Int]): Int
  
  axiom $map_sum_init_ax {
    ($map_sum(($map_init(0): $Map[Int, Int])): Int) == 0
  }
  
  axiom $map_sum_set_ax {
    (forall $m: $Map[$K, Int], $k: $K, $v: Int :: { ($map_sum(($map_set($m, $k, $v): $Map[$K, Int])): Int) } ($map_sum(($map_set($m, $k, $v): $Map[$K, Int])): Int) == ($map_sum($m): Int) - ($map_get($m, $k): Int) + $v)
  }
}

domain $Struct {
  
  function $struct_loc($s: $Struct, $m: Int): Int
}

domain $StructOps[$T] {
  
  function $struct_get($l: Int): $T
  
  function $struct_set($s: $Struct, $m: Int, $t: $T): $Struct
  
  axiom $get_set_0_ax {
    (forall $s: $Struct, $m: Int, $t: $T :: { $struct_loc(($struct_set($s, $m, $t): $Struct), $m) } ($struct_get($struct_loc(($struct_set($s, $m, $t): $Struct), $m)): $T) == $t)
  }
  
  axiom $get_set_1_ax {
    (forall $s: $Struct, $m: Int, $n: Int, $t: $T :: { $struct_loc(($struct_set($s, $n, $t): $Struct), $m) } $m != $n ==> $struct_loc($s, $m) == $struct_loc(($struct_set($s, $n, $t): $Struct), $m))
  }
}

domain $Convert {
  
  function $bytes32_to_signed_int($bb: Seq[Int]): Int
  
  function $bytes32_to_unsigned_int($bb: Seq[Int]): Int
  
  function $signed_int_to_bytes32($i: Int): Seq[Int]
  
  function $unsigned_int_to_bytes32($i: Int): Seq[Int]
  
  function $pad32($bb: Seq[Int]): Seq[Int]
  
  axiom $bytes32_to_signed_int_ax {
    (forall $bb: Seq[Int] :: { $bytes32_to_signed_int($bb) } |$bb| <= 32 ==> -57896044618658097711785492504343953926634992332820282019728792003956564819968 <= $bytes32_to_signed_int($bb) && $bytes32_to_signed_int($bb) <= 57896044618658097711785492504343953926634992332820282019728792003956564819967)
  }
  
  axiom $bytes32_to_unsigned_int_ax {
    (forall $bb: Seq[Int] :: { $bytes32_to_unsigned_int($bb) } |$bb| <= 32 ==> 0 <= $bytes32_to_unsigned_int($bb) && $bytes32_to_unsigned_int($bb) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  }
  
  axiom $signed_int_to_bytes32_ax {
    (forall $i: Int :: { $signed_int_to_bytes32($i) } -57896044618658097711785492504343953926634992332820282019728792003956564819968 <= $i && $i <= 57896044618658097711785492504343953926634992332820282019728792003956564819967 ==> |$signed_int_to_bytes32($i)| == 32)
  }
  
  axiom $unsigned_int_to_bytes32_ax {
    (forall $i: Int :: { $unsigned_int_to_bytes32($i) } -57896044618658097711785492504343953926634992332820282019728792003956564819968 <= $i && $i <= 57896044618658097711785492504343953926634992332820282019728792003956564819967 ==> |$unsigned_int_to_bytes32($i)| == 32)
  }
  
  axiom $pad32_len_ax {
    (forall $bb: Seq[Int] :: { $pad32($bb) } |$pad32($bb)| == 32)
  }
  
  axiom $pad32_vals_ax {
    (forall $bb: Seq[Int], $i: Int :: { $pad32($bb)[$i] } (let diff == (32 - |$bb|) in 0 <= $i && $i < |$pad32($bb)| ==> $pad32($bb)[$i] == ($i < diff ? 0 : $bb[$i - diff])))
  }
}

domain $Range {
  
  function $range($f: Int, $t: Int): Seq[Int]
  
  axiom $range_len_ax {
    (forall $f: Int, $t: Int :: { |$range($f, $t)| } |$range($f, $t)| == $t - $f)
  }
  
  axiom $range_lookup_ax {
    (forall $f: Int, $t: Int, $i: Int :: { $range($f, $t)[$i] } 0 <= $i && $i < |$range($f, $t)| ==> $range($f, $t)[$i] == $f + $i)
  }
}

domain $Blockchain {
  
  function $blockhash($no: Int): Seq[Int]
  
  function $method_id($bb: Seq[Int], $l: Int): Seq[Int]
  
  function $keccak256($s: Seq[Int]): Seq[Int]
  
  function $sha256($s: Seq[Int]): Seq[Int]
  
  function $ecrecover($s: Seq[Int], v: Int, r: Int, s: Int): Int
  
  function $ecadd($p: Seq[Int], $q: Seq[Int]): Seq[Int]
  
  function $ecmul($p: Seq[Int], $s: Int): Seq[Int]
  
  axiom $blockhash_ax {
    (forall $no: Int :: { $blockhash($no) } |$blockhash($no)| == 32)
  }
  
  axiom $method_id_ax {
    (forall $bb: Seq[Int], $l: Int :: { $method_id($bb, $l) } |$method_id($bb, $l)| == $l)
  }
  
  axiom $keccak256_ax {
    (forall $s: Seq[Int] :: { $keccak256($s) } |$keccak256($s)| == 32)
  }
  
  axiom $sha256_ax {
    (forall $s: Seq[Int] :: { $sha256($s) } |$sha256($s)| == 32)
  }
  
  axiom $ecadd_ax {
    (forall $p: Seq[Int], $q: Seq[Int] :: { $ecadd($p, $q) } |$ecadd($p, $q)| == 2)
  }
  
  axiom $ecmul_ax {
    (forall $p: Seq[Int], $s: Int :: { $ecmul($p, $s) } |$ecmul($p, $s)| == 2)
  }
}

domain $Contract {
  
  function $self_address(): Int
  
  function $implements($a: Int, $i: Int): Bool
  
  axiom $self_address_ax {
    $self_address() != 0
  }
}

domain s$struct$self {
  
  function s$struct$self$init($arg_0: Seq[Int], $arg_1: Seq[Int], $arg_2: Int, $arg_3: Int, $arg_4: $Map[Int, Int], $arg_5: $Map[Int, $Map[Int, Int]], $arg_6: Int, $arg_7: Int, $arg_8: Int, $arg_9: Int, $arg_10: Bool, $arg_11: $Map[Int, Int], $arg_12: $Map[Int, Int], $arg_13: Bool): $Struct
  
  function s$struct$self$eq($l: $Struct, $r: $Struct): Bool
  
  axiom s$struct$self$init$ax {
    (forall $arg_0: Seq[Int], $arg_1: Seq[Int], $arg_2: Int, $arg_3: Int, $arg_4: $Map[Int, Int], $arg_5: $Map[Int, $Map[Int, Int]], $arg_6: Int, $arg_7: Int, $arg_8: Int, $arg_9: Int, $arg_10: Bool, $arg_11: $Map[Int, Int], $arg_12: $Map[Int, Int], $arg_13: Bool :: { s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13) } ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), -1)): Int) == 9122519725869122497593506884710 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 0)): Seq[Int]) == $arg_0 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 1)): Seq[Int]) == $arg_1 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 2)): Int) == $arg_2 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 3)): Int) == $arg_3 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 4)): $Map[Int, Int]) == $arg_4 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 5)): $Map[Int, $Map[Int, Int]]) == $arg_5 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 6)): Int) == $arg_6 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 7)): Int) == $arg_7 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 8)): Int) == $arg_8 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 9)): Int) == $arg_9 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 10)): Bool) == $arg_10 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 11)): $Map[Int, Int]) == $arg_11 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 12)): $Map[Int, Int]) == $arg_12 && ($struct_get($struct_loc(s$struct$self$init($arg_0, $arg_1, $arg_2, $arg_3, $arg_4, $arg_5, $arg_6, $arg_7, $arg_8, $arg_9, $arg_10, $arg_11, $arg_12, $arg_13), 13)): Bool) == $arg_13)
  }
  
  axiom s$struct$self$eq$ax {
    (forall $l: $Struct, $r: $Struct :: { s$struct$self$eq($l, $r) } s$struct$self$eq($l, $r) == ($l == $r) && s$struct$self$eq($l, $r) == (($struct_get($struct_loc($l, -1)): Int) == ($struct_get($struct_loc($r, -1)): Int) && ($struct_get($struct_loc($l, 0)): Seq[Int]) == ($struct_get($struct_loc($r, 0)): Seq[Int]) && ($struct_get($struct_loc($l, 1)): Seq[Int]) == ($struct_get($struct_loc($r, 1)): Seq[Int]) && ($struct_get($struct_loc($l, 2)): Int) == ($struct_get($struct_loc($r, 2)): Int) && ($struct_get($struct_loc($l, 3)): Int) == ($struct_get($struct_loc($r, 3)): Int) && ($map_eq(($struct_get($struct_loc($l, 4)): $Map[Int, Int]), ($struct_get($struct_loc($r, 4)): $Map[Int, Int])): Bool) && ($map_eq(($struct_get($struct_loc($l, 5)): $Map[Int, $Map[Int, Int]]), ($struct_get($struct_loc($r, 5)): $Map[Int, $Map[Int, Int]])): Bool) && ($struct_get($struct_loc($l, 6)): Int) == ($struct_get($struct_loc($r, 6)): Int) && ($struct_get($struct_loc($l, 7)): Int) == ($struct_get($struct_loc($r, 7)): Int) && ($struct_get($struct_loc($l, 8)): Int) == ($struct_get($struct_loc($r, 8)): Int) && ($struct_get($struct_loc($l, 9)): Int) == ($struct_get($struct_loc($r, 9)): Int) && ($struct_get($struct_loc($l, 10)): Bool) == ($struct_get($struct_loc($r, 10)): Bool) && ($map_eq(($struct_get($struct_loc($l, 11)): $Map[Int, Int]), ($struct_get($struct_loc($r, 11)): $Map[Int, Int])): Bool) && ($map_eq(($struct_get($struct_loc($l, 12)): $Map[Int, Int]), ($struct_get($struct_loc($r, 12)): $Map[Int, Int])): Bool) && ($struct_get($struct_loc($l, 13)): Bool) == ($struct_get($struct_loc($r, 13)): Bool)))
  }
}

domain s$struct$EtherTokenPair {
  
  function s$struct$EtherTokenPair$init($arg_0: Int, $arg_1: Int): $Struct
  
  function s$struct$EtherTokenPair$eq($l: $Struct, $r: $Struct): Bool
  
  axiom s$struct$EtherTokenPair$init$ax {
    (forall $arg_0: Int, $arg_1: Int :: { s$struct$EtherTokenPair$init($arg_0, $arg_1) } ($struct_get($struct_loc(s$struct$EtherTokenPair$init($arg_0, $arg_1), -1)): Int) == 11028449636546951172565373718758303580017951889227344242 && ($struct_get($struct_loc(s$struct$EtherTokenPair$init($arg_0, $arg_1), 0)): Int) == $arg_0 && ($struct_get($struct_loc(s$struct$EtherTokenPair$init($arg_0, $arg_1), 1)): Int) == $arg_1)
  }
  
  axiom s$struct$EtherTokenPair$eq$ax {
    (forall $l: $Struct, $r: $Struct :: { s$struct$EtherTokenPair$eq($l, $r) } s$struct$EtherTokenPair$eq($l, $r) == ($l == $r) && s$struct$EtherTokenPair$eq($l, $r) == (($struct_get($struct_loc($l, -1)): Int) == ($struct_get($struct_loc($r, -1)): Int) && ($struct_get($struct_loc($l, 0)): Int) == ($struct_get($struct_loc($r, 0)): Int) && ($struct_get($struct_loc($l, 1)): Int) == ($struct_get($struct_loc($r, 1)): Int)))
  }
}

domain s$resource$$creator {
  
  function s$resource$$creator$init($arg_0: $Struct): $Struct
  
  function s$resource$$creator$eq($l: $Struct, $r: $Struct): Bool
  
  axiom s$resource$$creator$init$ax {
    (forall $arg_0: $Struct :: { s$resource$$creator$init($arg_0) } ($struct_get($struct_loc(s$resource$$creator$init($arg_0), -1)): Int) == 2567760667165796382711201132846784524754120562 && ($struct_get($struct_loc(s$resource$$creator$init($arg_0), 0)): $Struct) == $arg_0)
  }
  
  axiom s$resource$$creator$eq$ax {
    (forall $l: $Struct, $r: $Struct :: { s$resource$$creator$eq($l, $r) } s$resource$$creator$eq($l, $r) == ($l == $r) && s$resource$$creator$eq($l, $r) == (($struct_get($struct_loc($l, -1)): Int) == ($struct_get($struct_loc($r, -1)): Int) && ($struct_get($struct_loc($l, 0)): $Struct) == ($struct_get($struct_loc($r, 0)): $Struct)))
  }
}

domain $Implements {
  
  axiom $Implements$ax {
    true
  }
}

function $range_sum($x: Int, $y: Int): Int
  requires $x <= $y
{
  (let $x_ge_0 == ($x >= 0) in (let $y_ge_0 == ($y >= 0) in (let $x_exclusive == (($x_ge_0 ? ($x - 1) * $x / 2 : (-$x - 1) * -$x / 2)) in (let $y_exclusive == (($y_ge_0 ? ($y - 1) * $y / 2 : (-$y - 1) * -$y / 2)) in ($x_ge_0 && $y_ge_0 ? $y_exclusive - $x_exclusive : (!$x_ge_0 && $y_ge_0 ? $y_exclusive - $x_exclusive + $x : $y_exclusive - $y - $x_exclusive + $x))))))
}

function $pure$success_get(x: $Struct): Bool
{
  ($struct_get($struct_loc(x, 0)): Bool)
}

function $pure$return_get(x: $Struct): Int
  requires $pure$success_get(x)
{
  $struct_loc(x, 1)
}

predicate $failed($address: Int) 

predicate $failed_0($address: Int) 

predicate $allocation($resource: $Struct, $address: Int) 

predicate $allocation_0($resource: $Struct, $address: Int) 

predicate $offer($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_address: Int) 

predicate $offer_0($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_address: Int) 

predicate $trust($address: Int, $by_address: Int) 

predicate $trust_0($address: Int, $by_address: Int) 

predicate $performs$create($resource: $Struct, $from_address: Int, $to_address: Int, $amount: Int) 

predicate $performs$create_0($resource: $Struct, $from_address: Int, $to_address: Int, $amount: Int) 

predicate $performs$destroy($resource: $Struct, $from_address: Int, $amount: Int) 

predicate $performs$destroy_0($resource: $Struct, $from_address: Int, $amount: Int) 

predicate $performs$reallocate($resource: $Struct, $from_address: Int, $to_address: Int, $amount: Int) 

predicate $performs$reallocate_0($resource: $Struct, $from_address: Int, $to_address: Int, $amount: Int) 

predicate $performs$offer($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_address: Int, $times: Int) 

predicate $performs$offer_0($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_address: Int, $times: Int) 

predicate $performs$revoke($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_adress: Int) 

predicate $performs$revoke_0($from_resource: $Struct, $to_resource: $Struct, $from_amount: Int, $to_amount: Int, $from_address: Int, $to_adress: Int) 

predicate $performs$trust($address: Int, $by_address: Int, $value: Bool) 

predicate $performs$trust_0($address: Int, $by_address: Int, $value: Bool) 

predicate e$TokenPurchase($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$TokenPurchase_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$EthPurchase($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$EthPurchase_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$AddLiquidity($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$AddLiquidity_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$RemoveLiquidity($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$RemoveLiquidity_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$Transfer($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$Transfer_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$Approval($arg0: Int, $arg1: Int, $arg2: Int) 

predicate e$Approval_0($arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$setup($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$setup_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$addLiquidity($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$addLiquidity_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$removeLiquidity($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$removeLiquidity_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$getInputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$getInputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$getOutputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$getOutputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$ethToTokenInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$ethToTokenInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$__default__($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$__default___0($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$ethToTokenSwapInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$ethToTokenSwapInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$ethToTokenTransferInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$ethToTokenTransferInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$ethToTokenOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$ethToTokenOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$ethToTokenSwapOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$ethToTokenSwapOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$ethToTokenTransferOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$ethToTokenTransferOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$tokenToEthInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToEthInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToEthSwapInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$tokenToEthSwapInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$tokenToEthTransferInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$tokenToEthTransferInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$tokenToEthOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToEthOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToEthSwapOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$tokenToEthSwapOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$tokenToEthTransferOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$tokenToEthTransferOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int) 

predicate $accessible$tokenToTokenInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int, $arg6: Int) 

predicate $accessible$tokenToTokenInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int, $arg6: Int) 

predicate $accessible$tokenToTokenSwapInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToTokenSwapInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToTokenTransferInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToTokenTransferInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToTokenOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int, $arg6: Int) 

predicate $accessible$tokenToTokenOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int, $arg6: Int) 

predicate $accessible$tokenToTokenSwapOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToTokenSwapOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToTokenTransferOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToTokenTransferOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToExchangeSwapInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToExchangeSwapInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToExchangeTransferInput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToExchangeTransferInput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToExchangeSwapOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToExchangeSwapOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int) 

predicate $accessible$tokenToExchangeTransferOutput($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$tokenToExchangeTransferOutput_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int, $arg3: Int, $arg4: Int, $arg5: Int) 

predicate $accessible$getEthToTokenInputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getEthToTokenInputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getEthToTokenOutputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getEthToTokenOutputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getTokenToEthInputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getTokenToEthInputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getTokenToEthOutputPrice($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$getTokenToEthOutputPrice_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$tokenAddress($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$tokenAddress_0($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$factoryAddress($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$factoryAddress_0($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$balanceOf($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$balanceOf_0($tag: Int, $to: Int, $amount: Int, $arg0: Int) 

predicate $accessible$transfer($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$transfer_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$transferFrom($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$transferFrom_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int, $arg2: Int) 

predicate $accessible$approve($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$approve_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$allowance($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$allowance_0($tag: Int, $to: Int, $amount: Int, $arg0: Int, $arg1: Int) 

predicate $accessible$__init__($tag: Int, $to: Int, $amount: Int) 

predicate $accessible$__init___0($tag: Int, $to: Int, $amount: Int) 

method $transitivity_check()
{
  var $self$0: $Struct
  var $$contracts$0: $Map[Int, $Struct]
  var $self$1: $Struct
  var $$contracts$1: $Map[Int, $Struct]
  var $self$2: $Struct
  var $$contracts$2: $Map[Int, $Struct]
  var block: $Struct
  var $post: Bool
  inhale |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($self$0, 2)): Int) && ($struct_get($struct_loc($self$0, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($self$0, 3)): Int) && ($struct_get($struct_loc($self$0, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($self$0, 6)): Int) && ($struct_get($struct_loc($self$0, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$0, 7)): Int) && ($struct_get($struct_loc($self$0, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$0, 8)): Int) && ($struct_get($struct_loc($self$0, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$0, 9)): Int) && ($struct_get($struct_loc($self$0, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($self$0, -1)): Int) == 9122519725869122497593506884710
  inhale |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($self$1, 2)): Int) && ($struct_get($struct_loc($self$1, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($self$1, 3)): Int) && ($struct_get($struct_loc($self$1, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($self$1, 6)): Int) && ($struct_get($struct_loc($self$1, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$1, 7)): Int) && ($struct_get($struct_loc($self$1, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$1, 8)): Int) && ($struct_get($struct_loc($self$1, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$1, 9)): Int) && ($struct_get($struct_loc($self$1, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($self$1, -1)): Int) == 9122519725869122497593506884710
  inhale |($struct_get($struct_loc($self$2, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($self$2, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($self$2, 2)): Int) && ($struct_get($struct_loc($self$2, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($self$2, 3)): Int) && ($struct_get($struct_loc($self$2, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($self$2, 6)): Int) && ($struct_get($struct_loc($self$2, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$2, 7)): Int) && ($struct_get($struct_loc($self$2, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$2, 8)): Int) && ($struct_get($struct_loc($self$2, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$2, 9)): Int) && ($struct_get($struct_loc($self$2, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($self$2, -1)): Int) == 9122519725869122497593506884710
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int))
}

method $reflexivity_check()
{
  var $self$0: $Struct
  var $$contracts$0: $Map[Int, $Struct]
  var $self$1: $Struct
  var $$contracts$1: $Map[Int, $Struct]
  var block: $Struct
  var $post: Bool
  inhale |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($self$0, 2)): Int) && ($struct_get($struct_loc($self$0, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($self$0, 3)): Int) && ($struct_get($struct_loc($self$0, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($self$0, 6)): Int) && ($struct_get($struct_loc($self$0, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$0, 7)): Int) && ($struct_get($struct_loc($self$0, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$0, 8)): Int) && ($struct_get($struct_loc($self$0, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$0, 9)): Int) && ($struct_get($struct_loc($self$0, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($self$0, -1)): Int) == 9122519725869122497593506884710
  inhale |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($self$1, 2)): Int) && ($struct_get($struct_loc($self$1, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($self$1, 3)): Int) && ($struct_get($struct_loc($self$1, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($self$1, 6)): Int) && ($struct_get($struct_loc($self$1, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$1, 7)): Int) && ($struct_get($struct_loc($self$1, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($self$1, 8)): Int) && ($struct_get($struct_loc($self$1, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$1, 9)): Int) && ($struct_get($struct_loc($self$1, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($self$1, -1)): Int) == 9122519725869122497593506884710
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
}

method $forced_ether_check()
{
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $post: Bool
  var $havoc: Int
  var block: $Struct
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  inhale |($struct_get($struct_loc($pre_self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc($pre_self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc($pre_self, 2)): Int) && ($struct_get($struct_loc($pre_self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc($pre_self, 3)): Int) && ($struct_get($struct_loc($pre_self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc($pre_self, 6)): Int) && ($struct_get($struct_loc($pre_self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($pre_self, 7)): Int) && ($struct_get($struct_loc($pre_self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc($pre_self, 8)): Int) && ($struct_get($struct_loc($pre_self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($pre_self, 9)): Int) && ($struct_get($struct_loc($pre_self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc($pre_self, -1)): Int) == 9122519725869122497593506884710
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  inhale $havoc >= 0
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + $havoc): $Struct)
}

method f$setup(l$token_addr: Int) returns ($succ: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$token_addr && l$token_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!(($struct_get($struct_loc(self, 7)): Int) == 0 && ($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0)) {
    goto revert
  }
  self := ($struct_set(self, 7, ($struct_get($struct_loc(msg, 0)): Int)): $Struct)
  self := ($struct_set(self, 6, l$token_addr): $Struct)
  self := ($struct_set(self, 0, Seq(85, 110, 105, 115, 119, 97, 112, 32, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
  self := ($struct_set(self, 1, Seq(85, 78, 73, 45, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
  self := ($struct_set(self, 2, 18): $Struct)
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
  // Havoc state
  $contracts := l$havoc$1
}

method f$addLiquidity(l$min_liquidity: $Int, l$max_tokens: $Int, l$deadline: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$total_liquidity: $Int
  var l$eth_reserve: $Int
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$token_amount: $Int
  var l$liquidity_minted: $Int
  var l$havoc: $Map[Int, $Struct]
  var l$send_fail$1: Bool
  var l$raw_ret$1: Bool
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$havoc$1: $Map[Int, $Struct]
  var l$havoc$2: $Struct
  var l$havoc$3: $Map[Int, $Struct]
  var l$no_reentrant_call: Bool
  var l$havoc$4: $Map[Int, $Struct]
  var l$havoc$5: $Map[Int, $Struct]
  var l$send_fail$2: Bool
  var l$raw_ret$2: Int
  var l$token_amount$1: $Int
  var l$initial_liquidity: $Int
  var l$havoc$6: $Map[Int, $Struct]
  var l$send_fail$3: Bool
  var l$raw_ret$3: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$havoc$7: $Map[Int, $Struct]
  var l$havoc$8: $Struct
  var l$havoc$9: $Map[Int, $Struct]
  var l$no_reentrant_call$1: Bool
  var l$havoc$10: $Map[Int, $Struct]
  var l$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc$12: Int
  var l$havoc$13: Int
  var l$havoc$14: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$min_liquidity) && $unwrap(l$min_liquidity) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens) && $unwrap(l$max_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  if (!($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0))) {
    goto revert
  }
  l$total_liquidity := $wrap(($struct_get($struct_loc(self, 3)): Int))
  if ($unwrap(l$total_liquidity) > 0) {
    if (!($unwrap(l$min_liquidity) > 0)) {
      goto revert
    }
    if (($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) < 0) {
      goto revert
    }
    if (($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    l$eth_reserve := $wrap(($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    if (l$send_fail) {
      inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
      goto revert
    }
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    l$token_reserve := $wrap(l$raw_ret)
    if ($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) < 0) {
      goto revert
    }
    if ($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    if ($unwrap(l$eth_reserve) == 0) {
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) < 0) {
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 < 0) {
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    l$token_amount := $wrap($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1)
    if ($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) < 0) {
      goto revert
    }
    if ($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    if ($unwrap(l$eth_reserve) == 0) {
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) < 0) {
      goto revert
    }
    if ($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    l$liquidity_minted := (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) / $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
    if (!($unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity))) {
      goto revert
    }
    if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) < 0) {
      goto revert
    }
    if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)): $Map[Int, Int])): $Struct)
    if ($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) < 0) {
      goto revert
    }
    if ($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
      $overflow := true
      goto revert
    }
    self := ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)))): $Struct)
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc
    if (l$send_fail$1) {
      inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
      goto revert
    }
    // Copy state
    $contracts := $old_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    i1$$pre_self := self
    i1$$pre_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$1
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    self := l$havoc$2
    $contracts := l$havoc$3
    // Assume type assumptions
    inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
    inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
    inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
    inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
    inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
    // Assume local state invariants
    inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
    if (l$no_reentrant_call) {
      // Copy state
      self := $old_self
      $contracts := $old_$contracts
    }
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$4
    // Copy state
    $old_$contracts := i1$$pre_$contracts
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$5
    // Copy state
    $old_$contracts := i1$$pre_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    if (!l$raw_ret$1) {
      goto revert
    }
    // Event: AddLiquidity
    inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg, 1)): Int), $unwrap(l$token_amount)), write)
    // Event: Transfer
    inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$liquidity_minted)), write)
    $res := $unwrap(l$liquidity_minted)
    goto return
  } else {
    if (!(($struct_get($struct_loc(self, 7)): Int) != 0 && ($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000)) {
      goto revert
    }
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    inhale 0 <= l$raw_ret$2 && l$raw_ret$2 <= 1461501637330902918203684832716283019655932542975
    if (l$send_fail$2) {
      inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
      goto revert
    }
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    if (!(l$raw_ret$2 == $self_address())) {
      goto revert
    }
    l$token_amount$1 := l$max_tokens
    l$initial_liquidity := $wrap(($struct_get($struct_loc(self, 8)): Int))
    self := ($struct_set(self, 3, $unwrap(l$initial_liquidity)): $Struct)
    self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)): $Map[Int, Int])): $Struct)
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$6
    if (l$send_fail$3) {
      inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
      goto revert
    }
    // Copy state
    $contracts := $old_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    i3$$pre_self := self
    i3$$pre_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$7
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    self := l$havoc$8
    $contracts := l$havoc$9
    // Assume type assumptions
    inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
    inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
    inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
    inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
    inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
    // Assume local state invariants
    inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
    if (l$no_reentrant_call$1) {
      // Copy state
      self := $old_self
      $contracts := $old_$contracts
    }
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$10
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$havoc$11
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    if (!l$raw_ret$3) {
      goto revert
    }
    // Event: AddLiquidity
    inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg, 1)): Int), $unwrap(l$token_amount$1)), write)
    // Event: Transfer
    inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)), write)
    $res := $unwrap(l$initial_liquidity)
    goto return
  }
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc$12
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$13 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
  // Havoc state
  $contracts := l$havoc$14
}

method f$removeLiquidity(l$amount: $Int, l$min_eth: $Int, l$min_tokens: $Int, l$deadline: $Int) returns ($succ: Bool, $res: $Struct)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$total_liquidity: $Int
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$eth_amount: $Int
  var l$token_amount: $Int
  var l$havoc: $Map[Int, $Struct]
  var l$send_fail$1: Bool
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$havoc$1: $Map[Int, $Struct]
  var l$havoc$2: $Struct
  var l$havoc$3: $Map[Int, $Struct]
  var l$no_reentrant_call: Bool
  var l$havoc$4: $Map[Int, $Struct]
  var l$havoc$5: $Map[Int, $Struct]
  var l$havoc$6: $Map[Int, $Struct]
  var l$send_fail$2: Bool
  var l$raw_ret$1: Bool
  var i2$$pre_self: $Struct
  var i2$$pre_$contracts: $Map[Int, $Struct]
  var l$havoc$7: $Map[Int, $Struct]
  var l$havoc$8: $Struct
  var l$havoc$9: $Map[Int, $Struct]
  var l$no_reentrant_call$1: Bool
  var l$havoc$10: $Map[Int, $Struct]
  var l$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc$12: $Struct
  var l$havoc$13: Int
  var l$havoc$14: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$amount) && $unwrap(l$amount) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth) && $unwrap(l$min_eth) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_tokens) && $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!($unwrap(l$amount) > 0 && $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0))) {
    goto revert
  }
  l$total_liquidity := $wrap(($struct_get($struct_loc(self, 3)): Int))
  if (!($unwrap(l$total_liquidity) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$token_reserve := $wrap(l$raw_ret)
  if ($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$total_liquidity) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$eth_amount := (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
  if ($unwrap($w_mul(l$amount, l$token_reserve)) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$amount, l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$total_liquidity) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$token_amount := (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) / $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
  if (!($unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens))) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)): $Map[Int, Int])): $Struct)
  if ($unwrap(l$total_liquidity) - $unwrap(l$amount) < 0) {
    goto revert
  }
  if ($unwrap(l$total_liquidity) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) - $unwrap(l$amount)))): $Struct)
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$eth_amount)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + $unwrap(l$eth_amount)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$eth_amount)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc
  if (l$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(msg, 0)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i1$$pre_self := self
  i1$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$havoc$2
  $contracts := l$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$4
  // Copy state
  $old_$contracts := i1$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$5
  // Copy state
  $old_$contracts := i1$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$6
  if (l$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i2$$pre_self := self
  i2$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$havoc$8
  $contracts := l$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$10
  // Copy state
  $old_$contracts := i2$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$havoc$11
  // Copy state
  $old_$contracts := i2$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$raw_ret$1) {
    goto revert
  }
  // Event: RemoveLiquidity
  inhale acc(e$RemoveLiquidity(($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$eth_amount), $unwrap(l$token_amount)), write)
  // Event: Transfer
  inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), 0, $unwrap(l$amount)), write)
  $res := s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc$12
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$13 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
  // Havoc state
  $contracts := l$havoc$14
}

method f$__default__() returns ($succ: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$eth_sold: Int
  var l$i0$min_tokens: Int
  var l$i0$deadline: Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: Int
  var l$i2$input_reserve: Int
  var l$i2$output_reserve: $Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: Int
  var l$i0$tokens_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of ethToTokenInput
  l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
  l$i0$min_tokens := 1
  l$i0$deadline := ($struct_get($struct_loc(block, 4)): Int)
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  if (!(l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$eth_sold
  l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
  l$i2$output_reserve := l$i0$token_reserve
  if (!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)) {
    goto revert
  }
  if (l$i2$input_amount * 997 < 0) {
    goto revert
  }
  if (l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := l$i2$input_amount * 997
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0) {
    goto revert
  }
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
  if (l$i2$input_reserve * 1000 < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
  if (l$i2$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$tokens_bought := $wrap(i2$$res)
  if (!($unwrap(l$i0$tokens_bought) >= l$i0$min_tokens)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: TokenPurchase
  inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_bought)
  goto i0$return
  label i0$return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
  // Havoc state
  $contracts := l$havoc$1
}

method f$ethToTokenSwapInput(l$min_tokens: $Int, l$deadline: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$eth_sold: Int
  var l$i0$min_tokens: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: Int
  var l$i2$input_reserve: Int
  var l$i2$output_reserve: $Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: Int
  var l$i0$tokens_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$min_tokens) && $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of ethToTokenInput
  l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
  l$i0$min_tokens := l$min_tokens
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$eth_sold
  l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
  l$i2$output_reserve := l$i0$token_reserve
  if (!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)) {
    goto revert
  }
  if (l$i2$input_amount * 997 < 0) {
    goto revert
  }
  if (l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := l$i2$input_amount * 997
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0) {
    goto revert
  }
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
  if (l$i2$input_reserve * 1000 < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
  if (l$i2$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$tokens_bought := $wrap(i2$$res)
  if (!($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: TokenPurchase
  inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$ethToTokenTransferInput(l$min_tokens: $Int, l$deadline: $Int, l$recipient: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$eth_sold: Int
  var l$i0$min_tokens: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: Int
  var l$i2$input_reserve: Int
  var l$i2$output_reserve: $Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: Int
  var l$i0$tokens_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$min_tokens) && $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  if (!(l$recipient != $self_address() && l$recipient != 0)) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of ethToTokenInput
  l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
  l$i0$min_tokens := l$min_tokens
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$eth_sold
  l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
  l$i2$output_reserve := l$i0$token_reserve
  if (!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)) {
    goto revert
  }
  if (l$i2$input_amount * 997 < 0) {
    goto revert
  }
  if (l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := l$i2$input_amount * 997
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0) {
    goto revert
  }
  if (l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
  if (l$i2$input_reserve * 1000 < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0) {
    goto revert
  }
  if (l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
  if (l$i2$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) / l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$tokens_bought := $wrap(i2$$res)
  if (!($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: TokenPurchase
  inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$ethToTokenSwapOutput(l$tokens_bought: $Int, l$deadline: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_bought: $Int
  var l$i0$max_eth: Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$output_amount: $Int
  var l$i2$input_reserve: Int
  var l$i2$output_reserve: $Int
  var i2$$res: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_sold: $Int
  var l$i0$eth_refund: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of ethToTokenOutput
  l$i0$tokens_bought := l$tokens_bought
  l$i0$max_eth := ($struct_get($struct_loc(msg, 1)): Int)
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_bought) > 0 && l$i0$max_eth > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth < 0) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Inlined call of getOutputPrice
  l$i2$output_amount := l$i0$tokens_bought
  l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth
  l$i2$output_reserve := l$i0$token_reserve
  if (!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)) {
    goto revert
  }
  if (l$i2$input_reserve * $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if (l$i2$input_reserve * $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000)
  if ($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997)
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1))
  goto i2$return
  label i2$return
  l$i0$eth_sold := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if (l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$eth_refund := $wrap(l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1)
  if ($unwrap(l$i0$eth_refund) > 0) {
    if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$eth_refund)) {
      goto revert
    }
    self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$buyer, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$buyer): Int) + $unwrap(l$i0$eth_refund)): $Map[Int, Int])): $Struct)
    self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$eth_refund)): $Struct)
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc
    if (l$i0$send_fail$1) {
      inhale acc($failed(l$i0$buyer), write)
      goto revert
    }
    // Copy state
    $contracts := $old_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    i3$$pre_self := self
    i3$$pre_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$1
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    self := l$i0$havoc$2
    $contracts := l$i0$havoc$3
    // Assume type assumptions
    inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
    inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
    inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
    inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
    inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
    // Assume local state invariants
    inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
    if (l$i0$no_reentrant_call) {
      // Copy state
      self := $old_self
      $contracts := $old_$contracts
    }
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$4
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$5
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Event: TokenPurchase
  inhale acc(e$TokenPurchase(l$i0$buyer, $unwrap(l$i0$eth_sold) * 1, $unwrap(l$i0$tokens_bought)), write)
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i0$$res := $unwrap($wrap($unwrap(l$i0$eth_sold) * 1))
  goto i0$return
  label i0$return
  $res := $unwrap($wrap(i0$$res))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$ethToTokenTransferOutput(l$tokens_bought: $Int, l$deadline: $Int, l$recipient: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_bought: $Int
  var l$i0$max_eth: Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$output_amount: $Int
  var l$i2$input_reserve: Int
  var l$i2$output_reserve: $Int
  var i2$$res: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_sold: $Int
  var l$i0$eth_refund: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is payable
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
  self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
  // Function body
  if (!(l$recipient != $self_address() && l$recipient != 0)) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of ethToTokenOutput
  l$i0$tokens_bought := l$tokens_bought
  l$i0$max_eth := ($struct_get($struct_loc(msg, 1)): Int)
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_bought) > 0 && l$i0$max_eth > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth < 0) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Inlined call of getOutputPrice
  l$i2$output_amount := l$i0$tokens_bought
  l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) - l$i0$max_eth
  l$i2$output_reserve := l$i0$token_reserve
  if (!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)) {
    goto revert
  }
  if (l$i2$input_reserve * $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if (l$i2$input_reserve * $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap($wrap(l$i2$input_reserve * $unwrap(l$i2$output_amount))) * 1000)
  if ($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap($wrap($unwrap(l$i2$output_reserve) - $unwrap(l$i2$output_amount))) * 997)
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1))
  goto i2$return
  label i2$return
  l$i0$eth_sold := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if (l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$eth_refund := $wrap(l$i0$max_eth - $unwrap(l$i0$eth_sold) * 1)
  if ($unwrap(l$i0$eth_refund) > 0) {
    if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$eth_refund)) {
      goto revert
    }
    self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$buyer, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$buyer): Int) + $unwrap(l$i0$eth_refund)): $Map[Int, Int])): $Struct)
    self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$eth_refund)): $Struct)
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
    exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc
    if (l$i0$send_fail$1) {
      inhale acc($failed(l$i0$buyer), write)
      goto revert
    }
    // Copy state
    $contracts := $old_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
    // Copy state
    i3$$pre_self := self
    i3$$pre_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$1
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    self := l$i0$havoc$2
    $contracts := l$i0$havoc$3
    // Assume type assumptions
    inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
    inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
    inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
    inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
    inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
    inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
    inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
    inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
    // Assume local state invariants
    inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
    if (l$i0$no_reentrant_call) {
      // Copy state
      self := $old_self
      $contracts := $old_$contracts
    }
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$4
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_$contracts := $contracts
    // Havoc state
    $contracts := l$i0$havoc$5
    // Copy state
    $old_$contracts := i3$$pre_$contracts
    // Copy state
    $old_self := self
    $old_$contracts := $contracts
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  // Event: TokenPurchase
  inhale acc(e$TokenPurchase(l$i0$buyer, $unwrap(l$i0$eth_sold) * 1, $unwrap(l$i0$tokens_bought)), write)
  if ($unwrap(l$i0$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i0$$res := $unwrap($wrap($unwrap(l$i0$eth_sold) * 1))
  goto i0$return
  label i0$return
  $res := $unwrap($wrap(i0$$res))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToEthSwapInput(l$tokens_sold: $Int, l$min_eth: $Int, l$deadline: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_sold: $Int
  var l$i0$min_eth: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: $Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_bought: $Int
  var l$i0$wei_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth) && $unwrap(l$min_eth) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToEthInput
  l$i0$tokens_sold := l$tokens_sold
  l$i0$min_eth := l$min_eth
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_sold) > 0 && $unwrap(l$i0$min_eth) > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$tokens_sold
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := $wrap($unwrap(l$i2$input_amount) * 997)
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve)
  if ($unwrap(l$i2$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee))
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$eth_bought := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$wei_bought := $wrap($unwrap(l$i0$eth_bought) * 1)
  if (!($unwrap(l$i0$wei_bought) >= $unwrap(l$i0$min_eth))) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient): Int) + $unwrap(l$i0$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(l$i0$recipient), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$wei_bought)), write)
  i0$$res := $unwrap(l$i0$wei_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToEthTransferInput(l$tokens_sold: $Int, l$min_eth: $Int, l$deadline: $Int, l$recipient: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_sold: $Int
  var l$i0$min_eth: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: $Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_bought: $Int
  var l$i0$wei_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth) && $unwrap(l$min_eth) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!(l$recipient != $self_address() && l$recipient != 0)) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToEthInput
  l$i0$tokens_sold := l$tokens_sold
  l$i0$min_eth := l$min_eth
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_sold) > 0 && $unwrap(l$i0$min_eth) > 0))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$tokens_sold
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := $wrap($unwrap(l$i2$input_amount) * 997)
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve)
  if ($unwrap(l$i2$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee))
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$eth_bought := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$wei_bought := $wrap($unwrap(l$i0$eth_bought) * 1)
  if (!($unwrap(l$i0$wei_bought) >= $unwrap(l$i0$min_eth))) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient): Int) + $unwrap(l$i0$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(l$i0$recipient), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$wei_bought)), write)
  i0$$res := $unwrap(l$i0$wei_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToEthSwapOutput(l$eth_bought: $Int, l$max_tokens: $Int, l$deadline: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$eth_bought: $Int
  var l$i0$max_tokens: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$output_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$tokens_sold: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$eth_bought) && $unwrap(l$eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens) && $unwrap(l$max_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToEthOutput
  l$i0$eth_bought := l$eth_bought
  l$i0$max_tokens := l$max_tokens
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i0$eth_bought) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getOutputPrice
  l$i2$output_amount := l$i0$eth_bought
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000)
  if (l$i2$output_reserve - $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if (l$i2$output_reserve - $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997)
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1))
  goto i2$return
  label i2$return
  l$i0$tokens_sold := $wrap(i2$$res)
  if (!($unwrap(l$i0$max_tokens) >= $unwrap(l$i0$tokens_sold))) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$eth_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient): Int) + $unwrap(l$i0$eth_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$eth_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(l$i0$recipient), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$eth_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_sold)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToEthTransferOutput(l$eth_bought: $Int, l$max_tokens: $Int, l$deadline: $Int, l$recipient: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$eth_bought: $Int
  var l$i0$max_tokens: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$output_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$tokens_sold: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$eth_bought) && $unwrap(l$eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens) && $unwrap(l$max_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!(l$recipient != $self_address() && l$recipient != 0)) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToEthOutput
  l$i0$eth_bought := l$eth_bought
  l$i0$max_tokens := l$max_tokens
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i0$eth_bought) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getOutputPrice
  l$i2$output_amount := l$i0$eth_bought
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap($w_mul(l$i2$input_reserve, l$i2$output_amount)) * 1000)
  if (l$i2$output_reserve - $unwrap(l$i2$output_amount) < 0) {
    goto revert
  }
  if (l$i2$output_reserve - $unwrap(l$i2$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap($wrap(l$i2$output_reserve - $unwrap(l$i2$output_amount))) * 997)
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) + 1))
  goto i2$return
  label i2$return
  l$i0$tokens_sold := $wrap(i2$$res)
  if (!($unwrap(l$i0$max_tokens) >= $unwrap(l$i0$tokens_sold))) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$eth_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$recipient): Int) + $unwrap(l$i0$eth_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$eth_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(l$i0$recipient), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$eth_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_sold)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToTokenSwapInput(l$tokens_sold: $Int, l$min_tokens_bought: $Int, l$min_eth_bought: $Int, l$deadline: $Int, l$token_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$exchange_addr: Int
  var l$i1$tokens_sold: $Int
  var l$i1$min_tokens_bought: $Int
  var l$i1$min_eth_bought: $Int
  var l$i1$deadline: $Int
  var l$i1$buyer: Int
  var l$i1$recipient: Int
  var l$i1$exchange_addr: Int
  var i1$$res: Int
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$send_fail: Bool
  var l$i1$raw_ret: Int
  var l$i1$token_reserve: $Int
  var l$i3$input_amount: $Int
  var l$i3$input_reserve: $Int
  var l$i3$output_reserve: Int
  var i3$$res: Int
  var l$i3$input_amount_with_fee: $Int
  var l$i3$numerator: $Int
  var l$i3$denominator: $Int
  var l$i1$eth_bought: $Int
  var l$i1$wei_bought: $Int
  var l$i1$havoc: $Map[Int, $Struct]
  var l$i1$send_fail$1: Bool
  var l$i1$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$1: $Map[Int, $Struct]
  var l$i1$havoc$2: $Struct
  var l$i1$havoc$3: $Map[Int, $Struct]
  var l$i1$no_reentrant_call: Bool
  var l$i1$havoc$4: $Map[Int, $Struct]
  var l$i1$havoc$5: $Map[Int, $Struct]
  var l$i1$havoc$6: $Map[Int, $Struct]
  var l$i1$send_fail$2: Bool
  var l$i1$raw_ret$2: Int
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$7: $Map[Int, $Struct]
  var l$i1$havoc$8: $Struct
  var l$i1$havoc$9: $Map[Int, $Struct]
  var l$i1$no_reentrant_call$1: Bool
  var l$i1$havoc$10: $Map[Int, $Struct]
  var l$i1$havoc$11: $Map[Int, $Struct]
  var l$i1$tokens_bought: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_tokens_bought) && $unwrap(l$min_tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth_bought) && $unwrap(l$min_eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$token_addr && l$token_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 1461501637330902918203684832716283019655932542975
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$exchange_addr := l$raw_ret
  // Copy state
  i1$$pre_self := self
  i1$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenInput
  l$i1$tokens_sold := l$tokens_sold
  l$i1$min_tokens_bought := l$min_tokens_bought
  l$i1$min_eth_bought := l$min_eth_bought
  l$i1$deadline := l$deadline
  l$i1$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i1$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i1$tokens_sold) > 0 && ($unwrap(l$i1$min_tokens_bought) > 0 && $unwrap(l$i1$min_eth_bought) > 0))) {
    goto revert
  }
  if (!(l$i1$exchange_addr != $self_address() && l$i1$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret && l$i1$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$token_reserve := $wrap(l$i1$raw_ret)
  // Inlined call of getInputPrice
  l$i3$input_amount := l$i1$tokens_sold
  l$i3$input_reserve := l$i1$token_reserve
  l$i3$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i3$input_reserve) > 0 && l$i3$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$input_amount_with_fee := $wrap($unwrap(l$i3$input_amount) * 997)
  if ($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$numerator := $wrap($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve)
  if ($unwrap(l$i3$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$denominator := $wrap($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee))
  if ($unwrap(l$i3$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i3$$res := $unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator)))
  goto i3$return
  label i3$return
  l$i1$eth_bought := $wrap(i3$$res)
  if ($unwrap(l$i1$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i1$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$wei_bought := $wrap($unwrap(l$i1$eth_bought) * 1)
  if (!($unwrap(l$i1$wei_bought) >= $unwrap(l$i1$min_eth_bought))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc
  if (l$i1$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$2
  $contracts := l$i1$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$4
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$5
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i1$raw_ret$1) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i1$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr): Int) + $unwrap(l$i1$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i1$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$6
  inhale 0 <= l$i1$raw_ret$2 && l$i1$raw_ret$2 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$2) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$8
  $contracts := l$i1$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$10
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$11
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$tokens_bought := $wrap(l$i1$raw_ret$2)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i1$buyer, $unwrap(l$i1$tokens_sold), $unwrap(l$i1$wei_bought)), write)
  i1$$res := $unwrap(l$i1$tokens_bought)
  goto i1$return
  label i1$return
  $res := i1$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToTokenTransferInput(l$tokens_sold: $Int, l$min_tokens_bought: $Int, l$min_eth_bought: $Int, l$deadline: $Int, l$recipient: Int, l$token_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$exchange_addr: Int
  var l$i1$tokens_sold: $Int
  var l$i1$min_tokens_bought: $Int
  var l$i1$min_eth_bought: $Int
  var l$i1$deadline: $Int
  var l$i1$buyer: Int
  var l$i1$recipient: Int
  var l$i1$exchange_addr: Int
  var i1$$res: Int
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$send_fail: Bool
  var l$i1$raw_ret: Int
  var l$i1$token_reserve: $Int
  var l$i3$input_amount: $Int
  var l$i3$input_reserve: $Int
  var l$i3$output_reserve: Int
  var i3$$res: Int
  var l$i3$input_amount_with_fee: $Int
  var l$i3$numerator: $Int
  var l$i3$denominator: $Int
  var l$i1$eth_bought: $Int
  var l$i1$wei_bought: $Int
  var l$i1$havoc: $Map[Int, $Struct]
  var l$i1$send_fail$1: Bool
  var l$i1$raw_ret$1: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$1: $Map[Int, $Struct]
  var l$i1$havoc$2: $Struct
  var l$i1$havoc$3: $Map[Int, $Struct]
  var l$i1$no_reentrant_call: Bool
  var l$i1$havoc$4: $Map[Int, $Struct]
  var l$i1$havoc$5: $Map[Int, $Struct]
  var l$i1$havoc$6: $Map[Int, $Struct]
  var l$i1$send_fail$2: Bool
  var l$i1$raw_ret$2: Int
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$7: $Map[Int, $Struct]
  var l$i1$havoc$8: $Struct
  var l$i1$havoc$9: $Map[Int, $Struct]
  var l$i1$no_reentrant_call$1: Bool
  var l$i1$havoc$10: $Map[Int, $Struct]
  var l$i1$havoc$11: $Map[Int, $Struct]
  var l$i1$tokens_bought: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_tokens_bought) && $unwrap(l$min_tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth_bought) && $unwrap(l$min_eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$token_addr && l$token_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 1461501637330902918203684832716283019655932542975
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$exchange_addr := l$raw_ret
  // Copy state
  i1$$pre_self := self
  i1$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenInput
  l$i1$tokens_sold := l$tokens_sold
  l$i1$min_tokens_bought := l$min_tokens_bought
  l$i1$min_eth_bought := l$min_eth_bought
  l$i1$deadline := l$deadline
  l$i1$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$recipient := l$recipient
  l$i1$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i1$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i1$tokens_sold) > 0 && ($unwrap(l$i1$min_tokens_bought) > 0 && $unwrap(l$i1$min_eth_bought) > 0))) {
    goto revert
  }
  if (!(l$i1$exchange_addr != $self_address() && l$i1$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret && l$i1$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$token_reserve := $wrap(l$i1$raw_ret)
  // Inlined call of getInputPrice
  l$i3$input_amount := l$i1$tokens_sold
  l$i3$input_reserve := l$i1$token_reserve
  l$i3$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i3$input_reserve) > 0 && l$i3$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$input_amount_with_fee := $wrap($unwrap(l$i3$input_amount) * 997)
  if ($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$numerator := $wrap($unwrap(l$i3$input_amount_with_fee) * l$i3$output_reserve)
  if ($unwrap(l$i3$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$denominator := $wrap($unwrap(l$i3$input_reserve) * 1000 + $unwrap(l$i3$input_amount_with_fee))
  if ($unwrap(l$i3$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i3$$res := $unwrap((0 == $unwrap(l$i3$denominator) ? $wrap($unwrap(l$i3$numerator) / $unwrap(l$i3$denominator)) : $w_div(l$i3$numerator, l$i3$denominator)))
  goto i3$return
  label i3$return
  l$i1$eth_bought := $wrap(i3$$res)
  if ($unwrap(l$i1$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i1$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$wei_bought := $wrap($unwrap(l$i1$eth_bought) * 1)
  if (!($unwrap(l$i1$wei_bought) >= $unwrap(l$i1$min_eth_bought))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc
  if (l$i1$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$2
  $contracts := l$i1$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$4
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$5
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i1$raw_ret$1) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i1$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr): Int) + $unwrap(l$i1$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i1$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$6
  inhale 0 <= l$i1$raw_ret$2 && l$i1$raw_ret$2 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$2) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$8
  $contracts := l$i1$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$10
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$11
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$tokens_bought := $wrap(l$i1$raw_ret$2)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i1$buyer, $unwrap(l$i1$tokens_sold), $unwrap(l$i1$wei_bought)), write)
  i1$$res := $unwrap(l$i1$tokens_bought)
  goto i1$return
  label i1$return
  $res := i1$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToTokenSwapOutput(l$tokens_bought: $Int, l$max_tokens_sold: $Int, l$max_eth_sold: $Int, l$deadline: $Int, l$token_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$exchange_addr: Int
  var l$i1$tokens_bought: $Int
  var l$i1$max_tokens_sold: $Int
  var l$i1$max_eth_sold: $Int
  var l$i1$deadline: $Int
  var l$i1$buyer: Int
  var l$i1$recipient: Int
  var l$i1$exchange_addr: Int
  var i1$$res: Int
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$send_fail: Bool
  var l$i1$raw_ret: Int
  var l$i1$eth_bought: Int
  var l$i1$send_fail$1: Bool
  var l$i1$raw_ret$1: Int
  var l$i1$token_reserve: $Int
  var l$i4$output_amount: Int
  var l$i4$input_reserve: $Int
  var l$i4$output_reserve: Int
  var i4$$res: Int
  var l$i4$numerator: $Int
  var l$i4$denominator: Int
  var l$i1$tokens_sold: $Int
  var l$i1$havoc: $Map[Int, $Struct]
  var l$i1$send_fail$2: Bool
  var l$i1$raw_ret$2: Bool
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$1: $Map[Int, $Struct]
  var l$i1$havoc$2: $Struct
  var l$i1$havoc$3: $Map[Int, $Struct]
  var l$i1$no_reentrant_call: Bool
  var l$i1$havoc$4: $Map[Int, $Struct]
  var l$i1$havoc$5: $Map[Int, $Struct]
  var l$i1$havoc$6: $Map[Int, $Struct]
  var l$i1$send_fail$3: Bool
  var l$i1$raw_ret$3: Int
  var i6$$pre_self: $Struct
  var i6$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$7: $Map[Int, $Struct]
  var l$i1$havoc$8: $Struct
  var l$i1$havoc$9: $Map[Int, $Struct]
  var l$i1$no_reentrant_call$1: Bool
  var l$i1$havoc$10: $Map[Int, $Struct]
  var l$i1$havoc$11: $Map[Int, $Struct]
  var l$i1$eth_sold: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens_sold) && $unwrap(l$max_tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_eth_sold) && $unwrap(l$max_eth_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$token_addr && l$token_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 1461501637330902918203684832716283019655932542975
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$exchange_addr := l$raw_ret
  // Copy state
  i1$$pre_self := self
  i1$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenOutput
  l$i1$tokens_bought := l$tokens_bought
  l$i1$max_tokens_sold := l$max_tokens_sold
  l$i1$max_eth_sold := l$max_eth_sold
  l$i1$deadline := l$deadline
  l$i1$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i1$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i1$tokens_bought) > 0 && $unwrap(l$i1$max_eth_sold) > 0))) {
    goto revert
  }
  if (!(l$i1$exchange_addr != $self_address() && l$i1$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret && l$i1$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$eth_bought := l$i1$raw_ret
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret$1 && l$i1$raw_ret$1 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$token_reserve := $wrap(l$i1$raw_ret$1)
  // Inlined call of getOutputPrice
  l$i4$output_amount := l$i1$eth_bought
  l$i4$input_reserve := l$i1$token_reserve
  l$i4$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i4$input_reserve) > 0 && l$i4$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i4$input_reserve) * l$i4$output_amount < 0) {
    goto revert
  }
  if ($unwrap(l$i4$input_reserve) * l$i4$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i4$numerator := $wrap($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000)
  if (l$i4$output_reserve - l$i4$output_amount < 0) {
    goto revert
  }
  if (l$i4$output_reserve - l$i4$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ((l$i4$output_reserve - l$i4$output_amount) * 997 < 0) {
    goto revert
  }
  if ((l$i4$output_reserve - l$i4$output_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i4$denominator := (l$i4$output_reserve - l$i4$output_amount) * 997
  if (l$i4$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1 < 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i4$$res := $unwrap($wrap($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1))
  goto i4$return
  label i4$return
  l$i1$tokens_sold := $wrap(i4$$res)
  if (!($unwrap(l$i1$max_tokens_sold) >= $unwrap(l$i1$tokens_sold) && $unwrap(l$i1$max_eth_sold) >= l$i1$eth_bought)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc
  if (l$i1$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$2
  $contracts := l$i1$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$4
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$5
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i1$raw_ret$2) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < l$i1$eth_bought) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr): Int) + l$i1$eth_bought): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - l$i1$eth_bought): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$6
  inhale 0 <= l$i1$raw_ret$3 && l$i1$raw_ret$3 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$3) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i6$$pre_self := self
  i6$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$8
  $contracts := l$i1$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$10
  // Copy state
  $old_$contracts := i6$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$11
  // Copy state
  $old_$contracts := i6$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$eth_sold := $wrap(l$i1$raw_ret$3)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i1$buyer, $unwrap(l$i1$tokens_sold), l$i1$eth_bought), write)
  i1$$res := $unwrap(l$i1$tokens_sold)
  goto i1$return
  label i1$return
  $res := i1$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToTokenTransferOutput(l$tokens_bought: $Int, l$max_tokens_sold: $Int, l$max_eth_sold: $Int, l$deadline: $Int, l$recipient: Int, l$token_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$exchange_addr: Int
  var l$i1$tokens_bought: $Int
  var l$i1$max_tokens_sold: $Int
  var l$i1$max_eth_sold: $Int
  var l$i1$deadline: $Int
  var l$i1$buyer: Int
  var l$i1$recipient: Int
  var l$i1$exchange_addr: Int
  var i1$$res: Int
  var i1$$pre_self: $Struct
  var i1$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$send_fail: Bool
  var l$i1$raw_ret: Int
  var l$i1$eth_bought: Int
  var l$i1$send_fail$1: Bool
  var l$i1$raw_ret$1: Int
  var l$i1$token_reserve: $Int
  var l$i4$output_amount: Int
  var l$i4$input_reserve: $Int
  var l$i4$output_reserve: Int
  var i4$$res: Int
  var l$i4$numerator: $Int
  var l$i4$denominator: Int
  var l$i1$tokens_sold: $Int
  var l$i1$havoc: $Map[Int, $Struct]
  var l$i1$send_fail$2: Bool
  var l$i1$raw_ret$2: Bool
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$1: $Map[Int, $Struct]
  var l$i1$havoc$2: $Struct
  var l$i1$havoc$3: $Map[Int, $Struct]
  var l$i1$no_reentrant_call: Bool
  var l$i1$havoc$4: $Map[Int, $Struct]
  var l$i1$havoc$5: $Map[Int, $Struct]
  var l$i1$havoc$6: $Map[Int, $Struct]
  var l$i1$send_fail$3: Bool
  var l$i1$raw_ret$3: Int
  var i6$$pre_self: $Struct
  var i6$$pre_$contracts: $Map[Int, $Struct]
  var l$i1$havoc$7: $Map[Int, $Struct]
  var l$i1$havoc$8: $Struct
  var l$i1$havoc$9: $Map[Int, $Struct]
  var l$i1$no_reentrant_call$1: Bool
  var l$i1$havoc$10: $Map[Int, $Struct]
  var l$i1$havoc$11: $Map[Int, $Struct]
  var l$i1$eth_sold: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens_sold) && $unwrap(l$max_tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_eth_sold) && $unwrap(l$max_eth_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$token_addr && l$token_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 1461501637330902918203684832716283019655932542975
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$exchange_addr := l$raw_ret
  // Copy state
  i1$$pre_self := self
  i1$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenOutput
  l$i1$tokens_bought := l$tokens_bought
  l$i1$max_tokens_sold := l$max_tokens_sold
  l$i1$max_eth_sold := l$max_eth_sold
  l$i1$deadline := l$deadline
  l$i1$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i1$recipient := l$recipient
  l$i1$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i1$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i1$tokens_bought) > 0 && $unwrap(l$i1$max_eth_sold) > 0))) {
    goto revert
  }
  if (!(l$i1$exchange_addr != $self_address() && l$i1$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret && l$i1$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$eth_bought := l$i1$raw_ret
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i1$raw_ret$1 && l$i1$raw_ret$1 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$token_reserve := $wrap(l$i1$raw_ret$1)
  // Inlined call of getOutputPrice
  l$i4$output_amount := l$i1$eth_bought
  l$i4$input_reserve := l$i1$token_reserve
  l$i4$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i4$input_reserve) > 0 && l$i4$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i4$input_reserve) * l$i4$output_amount < 0) {
    goto revert
  }
  if ($unwrap(l$i4$input_reserve) * l$i4$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i4$numerator := $wrap($unwrap($wrap($unwrap(l$i4$input_reserve) * l$i4$output_amount)) * 1000)
  if (l$i4$output_reserve - l$i4$output_amount < 0) {
    goto revert
  }
  if (l$i4$output_reserve - l$i4$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ((l$i4$output_reserve - l$i4$output_amount) * 997 < 0) {
    goto revert
  }
  if ((l$i4$output_reserve - l$i4$output_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i4$denominator := (l$i4$output_reserve - l$i4$output_amount) * 997
  if (l$i4$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1 < 0) {
    goto revert
  }
  if ($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i4$$res := $unwrap($wrap($div($unwrap(l$i4$numerator), l$i4$denominator, $unwrap(l$i4$numerator) / l$i4$denominator) + 1))
  goto i4$return
  label i4$return
  l$i1$tokens_sold := $wrap(i4$$res)
  if (!($unwrap(l$i1$max_tokens_sold) >= $unwrap(l$i1$tokens_sold) && $unwrap(l$i1$max_eth_sold) >= l$i1$eth_bought)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc
  if (l$i1$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$2
  $contracts := l$i1$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$4
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$5
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i1$raw_ret$2) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < l$i1$eth_bought) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i1$exchange_addr): Int) + l$i1$eth_bought): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - l$i1$eth_bought): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$6
  inhale 0 <= l$i1$raw_ret$3 && l$i1$raw_ret$3 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i1$send_fail$3) {
    inhale acc($failed(l$i1$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i6$$pre_self := self
  i6$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i1$havoc$8
  $contracts := l$i1$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i1$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$10
  // Copy state
  $old_$contracts := i6$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i1$havoc$11
  // Copy state
  $old_$contracts := i6$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i1$eth_sold := $wrap(l$i1$raw_ret$3)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i1$buyer, $unwrap(l$i1$tokens_sold), l$i1$eth_bought), write)
  i1$$res := $unwrap(l$i1$tokens_sold)
  goto i1$return
  label i1$return
  $res := i1$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToExchangeSwapInput(l$tokens_sold: $Int, l$min_tokens_bought: $Int, l$min_eth_bought: $Int, l$deadline: $Int, l$exchange_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_sold: $Int
  var l$i0$min_tokens_bought: $Int
  var l$i0$min_eth_bought: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var l$i0$exchange_addr: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: $Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_bought: $Int
  var l$i0$wei_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$2: Int
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var l$i0$tokens_bought: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_tokens_bought) && $unwrap(l$min_tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth_bought) && $unwrap(l$min_eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$exchange_addr && l$exchange_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenInput
  l$i0$tokens_sold := l$tokens_sold
  l$i0$min_tokens_bought := l$min_tokens_bought
  l$i0$min_eth_bought := l$min_eth_bought
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i0$tokens_sold) > 0 && ($unwrap(l$i0$min_tokens_bought) > 0 && $unwrap(l$i0$min_eth_bought) > 0))) {
    goto revert
  }
  if (!(l$i0$exchange_addr != $self_address() && l$i0$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$tokens_sold
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := $wrap($unwrap(l$i2$input_amount) * 997)
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve)
  if ($unwrap(l$i2$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee))
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$eth_bought := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$wei_bought := $wrap($unwrap(l$i0$eth_bought) * 1)
  if (!($unwrap(l$i0$wei_bought) >= $unwrap(l$i0$min_eth_bought))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr): Int) + $unwrap(l$i0$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  inhale 0 <= l$i0$raw_ret$2 && l$i0$raw_ret$2 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$2) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$tokens_bought := $wrap(l$i0$raw_ret$2)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$wei_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToExchangeTransferInput(l$tokens_sold: $Int, l$min_tokens_bought: $Int, l$min_eth_bought: $Int, l$deadline: $Int, l$recipient: Int, l$exchange_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_sold: $Int
  var l$i0$min_tokens_bought: $Int
  var l$i0$min_eth_bought: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var l$i0$exchange_addr: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$token_reserve: $Int
  var l$i2$input_amount: $Int
  var l$i2$input_reserve: $Int
  var l$i2$output_reserve: Int
  var i2$$res: Int
  var l$i2$input_amount_with_fee: $Int
  var l$i2$numerator: $Int
  var l$i2$denominator: $Int
  var l$i0$eth_bought: $Int
  var l$i0$wei_bought: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Bool
  var i3$$pre_self: $Struct
  var i3$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$2: Int
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var l$i0$tokens_bought: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_tokens_bought) && $unwrap(l$min_tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$min_eth_bought) && $unwrap(l$min_eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$exchange_addr && l$exchange_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!(l$recipient != $self_address())) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenInput
  l$i0$tokens_sold := l$tokens_sold
  l$i0$min_tokens_bought := l$min_tokens_bought
  l$i0$min_eth_bought := l$min_eth_bought
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  l$i0$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && $unwrap(l$i0$tokens_sold) > 0 && ($unwrap(l$i0$min_tokens_bought) > 0 && $unwrap(l$i0$min_eth_bought) > 0))) {
    goto revert
  }
  if (!(l$i0$exchange_addr != $self_address() && l$i0$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret)
  // Inlined call of getInputPrice
  l$i2$input_amount := l$i0$tokens_sold
  l$i2$input_reserve := l$i0$token_reserve
  l$i2$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i2$input_reserve) > 0 && l$i2$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$input_amount_with_fee := $wrap($unwrap(l$i2$input_amount) * 997)
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$numerator := $wrap($unwrap(l$i2$input_amount_with_fee) * l$i2$output_reserve)
  if ($unwrap(l$i2$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i2$denominator := $wrap($unwrap(l$i2$input_reserve) * 1000 + $unwrap(l$i2$input_amount_with_fee))
  if ($unwrap(l$i2$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i2$$res := $unwrap((0 == $unwrap(l$i2$denominator) ? $wrap($unwrap(l$i2$numerator) / $unwrap(l$i2$denominator)) : $w_div(l$i2$numerator, l$i2$denominator)))
  goto i2$return
  label i2$return
  l$i0$eth_bought := $wrap(i2$$res)
  if ($unwrap(l$i0$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$i0$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i0$wei_bought := $wrap($unwrap(l$i0$eth_bought) * 1)
  if (!($unwrap(l$i0$wei_bought) >= $unwrap(l$i0$min_eth_bought))) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i3$$pre_self := self
  i3$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i3$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$1) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$i0$wei_bought)) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr): Int) + $unwrap(l$i0$wei_bought)): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$i0$wei_bought)): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  inhale 0 <= l$i0$raw_ret$2 && l$i0$raw_ret$2 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$2) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$tokens_bought := $wrap(l$i0$raw_ret$2)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), $unwrap(l$i0$wei_bought)), write)
  i0$$res := $unwrap(l$i0$tokens_bought)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToExchangeSwapOutput(l$tokens_bought: $Int, l$max_tokens_sold: $Int, l$max_eth_sold: $Int, l$deadline: $Int, l$exchange_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_bought: $Int
  var l$i0$max_tokens_sold: $Int
  var l$i0$max_eth_sold: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var l$i0$exchange_addr: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$eth_bought: Int
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Int
  var l$i0$token_reserve: $Int
  var l$i3$output_amount: Int
  var l$i3$input_reserve: $Int
  var l$i3$output_reserve: Int
  var i3$$res: Int
  var l$i3$numerator: $Int
  var l$i3$denominator: Int
  var l$i0$tokens_sold: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$2: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$3: Bool
  var l$i0$raw_ret$3: Int
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var l$i0$eth_sold: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens_sold) && $unwrap(l$max_tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_eth_sold) && $unwrap(l$max_eth_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$exchange_addr && l$exchange_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenOutput
  l$i0$tokens_bought := l$tokens_bought
  l$i0$max_tokens_sold := l$max_tokens_sold
  l$i0$max_eth_sold := l$max_eth_sold
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_bought) > 0 && $unwrap(l$i0$max_eth_sold) > 0))) {
    goto revert
  }
  if (!(l$i0$exchange_addr != $self_address() && l$i0$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$eth_bought := l$i0$raw_ret
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret$1 && l$i0$raw_ret$1 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret$1)
  // Inlined call of getOutputPrice
  l$i3$output_amount := l$i0$eth_bought
  l$i3$input_reserve := l$i0$token_reserve
  l$i3$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i3$input_reserve) > 0 && l$i3$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * l$i3$output_amount < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * l$i3$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$numerator := $wrap($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000)
  if (l$i3$output_reserve - l$i3$output_amount < 0) {
    goto revert
  }
  if (l$i3$output_reserve - l$i3$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ((l$i3$output_reserve - l$i3$output_amount) * 997 < 0) {
    goto revert
  }
  if ((l$i3$output_reserve - l$i3$output_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$denominator := (l$i3$output_reserve - l$i3$output_amount) * 997
  if (l$i3$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1 < 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i3$$res := $unwrap($wrap($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1))
  goto i3$return
  label i3$return
  l$i0$tokens_sold := $wrap(i3$$res)
  if (!($unwrap(l$i0$max_tokens_sold) >= $unwrap(l$i0$tokens_sold) && $unwrap(l$i0$max_eth_sold) >= l$i0$eth_bought)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$2) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < l$i0$eth_bought) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr): Int) + l$i0$eth_bought): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_bought): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  inhale 0 <= l$i0$raw_ret$3 && l$i0$raw_ret$3 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$3) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$eth_sold := $wrap(l$i0$raw_ret$3)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), l$i0$eth_bought), write)
  i0$$res := $unwrap(l$i0$tokens_sold)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenToExchangeTransferOutput(l$tokens_bought: $Int, l$max_tokens_sold: $Int, l$max_eth_sold: $Int, l$deadline: $Int, l$recipient: Int, l$exchange_addr: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$i0$tokens_bought: $Int
  var l$i0$max_tokens_sold: $Int
  var l$i0$max_eth_sold: $Int
  var l$i0$deadline: $Int
  var l$i0$buyer: Int
  var l$i0$recipient: Int
  var l$i0$exchange_addr: Int
  var i0$$res: Int
  var i0$$pre_self: $Struct
  var i0$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$send_fail: Bool
  var l$i0$raw_ret: Int
  var l$i0$eth_bought: Int
  var l$i0$send_fail$1: Bool
  var l$i0$raw_ret$1: Int
  var l$i0$token_reserve: $Int
  var l$i3$output_amount: Int
  var l$i3$input_reserve: $Int
  var l$i3$output_reserve: Int
  var i3$$res: Int
  var l$i3$numerator: $Int
  var l$i3$denominator: Int
  var l$i0$tokens_sold: $Int
  var l$i0$havoc: $Map[Int, $Struct]
  var l$i0$send_fail$2: Bool
  var l$i0$raw_ret$2: Bool
  var i4$$pre_self: $Struct
  var i4$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$1: $Map[Int, $Struct]
  var l$i0$havoc$2: $Struct
  var l$i0$havoc$3: $Map[Int, $Struct]
  var l$i0$no_reentrant_call: Bool
  var l$i0$havoc$4: $Map[Int, $Struct]
  var l$i0$havoc$5: $Map[Int, $Struct]
  var l$i0$havoc$6: $Map[Int, $Struct]
  var l$i0$send_fail$3: Bool
  var l$i0$raw_ret$3: Int
  var i5$$pre_self: $Struct
  var i5$$pre_$contracts: $Map[Int, $Struct]
  var l$i0$havoc$7: $Map[Int, $Struct]
  var l$i0$havoc$8: $Struct
  var l$i0$havoc$9: $Map[Int, $Struct]
  var l$i0$no_reentrant_call$1: Bool
  var l$i0$havoc$10: $Map[Int, $Struct]
  var l$i0$havoc$11: $Map[Int, $Struct]
  var l$i0$eth_sold: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_tokens_sold) && $unwrap(l$max_tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$max_eth_sold) && $unwrap(l$max_eth_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= $unwrap(l$deadline) && $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= l$recipient && l$recipient <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$exchange_addr && l$exchange_addr <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!(l$recipient != $self_address())) {
    goto revert
  }
  // Copy state
  i0$$pre_self := self
  i0$$pre_$contracts := $contracts
  // Inlined call of tokenToTokenOutput
  l$i0$tokens_bought := l$tokens_bought
  l$i0$max_tokens_sold := l$max_tokens_sold
  l$i0$max_eth_sold := l$max_eth_sold
  l$i0$deadline := l$deadline
  l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
  l$i0$recipient := l$recipient
  l$i0$exchange_addr := l$exchange_addr
  if (!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$i0$tokens_bought) > 0 && $unwrap(l$i0$max_eth_sold) > 0))) {
    goto revert
  }
  if (!(l$i0$exchange_addr != $self_address() && l$i0$exchange_addr != 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret && l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$eth_bought := l$i0$raw_ret
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$i0$raw_ret$1 && l$i0$raw_ret$1 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$1) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$token_reserve := $wrap(l$i0$raw_ret$1)
  // Inlined call of getOutputPrice
  l$i3$output_amount := l$i0$eth_bought
  l$i3$input_reserve := l$i0$token_reserve
  l$i3$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i3$input_reserve) > 0 && l$i3$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * l$i3$output_amount < 0) {
    goto revert
  }
  if ($unwrap(l$i3$input_reserve) * l$i3$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$numerator := $wrap($unwrap($wrap($unwrap(l$i3$input_reserve) * l$i3$output_amount)) * 1000)
  if (l$i3$output_reserve - l$i3$output_amount < 0) {
    goto revert
  }
  if (l$i3$output_reserve - l$i3$output_amount > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ((l$i3$output_reserve - l$i3$output_amount) * 997 < 0) {
    goto revert
  }
  if ((l$i3$output_reserve - l$i3$output_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i3$denominator := (l$i3$output_reserve - l$i3$output_amount) * 997
  if (l$i3$denominator == 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) < 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1 < 0) {
    goto revert
  }
  if ($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i3$$res := $unwrap($wrap($div($unwrap(l$i3$numerator), l$i3$denominator, $unwrap(l$i3$numerator) / l$i3$denominator) + 1))
  goto i3$return
  label i3$return
  l$i0$tokens_sold := $wrap(i3$$res)
  if (!($unwrap(l$i0$max_tokens_sold) >= $unwrap(l$i0$tokens_sold) && $unwrap(l$i0$max_eth_sold) >= l$i0$eth_bought)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc
  if (l$i0$send_fail$2) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i4$$pre_self := self
  i4$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$1
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$2
  $contracts := l$i0$havoc$3
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$4
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$5
  // Copy state
  $old_$contracts := i4$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  if (!l$i0$raw_ret$2) {
    goto revert
  }
  if (($struct_get($struct_loc(self, 8)): Int) < l$i0$eth_bought) {
    goto revert
  }
  self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr, ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), l$i0$exchange_addr): Int) + l$i0$eth_bought): $Map[Int, Int])): $Struct)
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_bought): $Struct)
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$6
  inhale 0 <= l$i0$raw_ret$3 && l$i0$raw_ret$3 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$i0$send_fail$3) {
    inhale acc($failed(l$i0$exchange_addr), write)
    goto revert
  }
  // Copy state
  $contracts := $old_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  i5$$pre_self := self
  i5$$pre_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$7
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  self := l$i0$havoc$8
  $contracts := l$i0$havoc$9
  // Assume type assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume local state invariants
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
  if (l$i0$no_reentrant_call$1) {
    // Copy state
    self := $old_self
    $contracts := $old_$contracts
  }
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$10
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_$contracts := $contracts
  // Havoc state
  $contracts := l$i0$havoc$11
  // Copy state
  $old_$contracts := i5$$pre_$contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$i0$eth_sold := $wrap(l$i0$raw_ret$3)
  // Event: EthPurchase
  inhale acc(e$EthPurchase(l$i0$buyer, $unwrap(l$i0$tokens_sold), l$i0$eth_bought), write)
  i0$$res := $unwrap(l$i0$tokens_sold)
  goto i0$return
  label i0$return
  $res := i0$$res
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$getEthToTokenInputPrice(l$eth_sold: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$i1$input_amount: $Int
  var l$i1$input_reserve: Int
  var l$i1$output_reserve: $Int
  var i1$$res: Int
  var l$i1$input_amount_with_fee: $Int
  var l$i1$numerator: $Int
  var l$i1$denominator: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$eth_sold) && $unwrap(l$eth_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!($unwrap(l$eth_sold) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$token_reserve := $wrap(l$raw_ret)
  // Inlined call of getInputPrice
  l$i1$input_amount := l$eth_sold
  l$i1$input_reserve := ($struct_get($struct_loc(self, 8)): Int)
  l$i1$output_reserve := l$token_reserve
  if (!(l$i1$input_reserve > 0 && $unwrap(l$i1$output_reserve) > 0)) {
    goto revert
  }
  if ($unwrap(l$i1$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i1$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$input_amount_with_fee := $wrap($unwrap(l$i1$input_amount) * 997)
  if ($unwrap($w_mul(l$i1$input_amount_with_fee, l$i1$output_reserve)) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i1$input_amount_with_fee, l$i1$output_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$numerator := $w_mul(l$i1$input_amount_with_fee, l$i1$output_reserve)
  if (l$i1$input_reserve * 1000 < 0) {
    goto revert
  }
  if (l$i1$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if (l$i1$input_reserve * 1000 + $unwrap(l$i1$input_amount_with_fee) < 0) {
    goto revert
  }
  if (l$i1$input_reserve * 1000 + $unwrap(l$i1$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$denominator := $wrap(l$i1$input_reserve * 1000 + $unwrap(l$i1$input_amount_with_fee))
  if ($unwrap(l$i1$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i1$$res := $unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator)))
  goto i1$return
  label i1$return
  $res := $unwrap($wrap(i1$$res))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$getEthToTokenOutputPrice(l$tokens_bought: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$i1$output_amount: $Int
  var l$i1$input_reserve: Int
  var l$i1$output_reserve: $Int
  var i1$$res: Int
  var l$i1$numerator: $Int
  var l$i1$denominator: $Int
  var l$eth_sold: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_bought) && $unwrap(l$tokens_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!($unwrap(l$tokens_bought) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$token_reserve := $wrap(l$raw_ret)
  // Inlined call of getOutputPrice
  l$i1$output_amount := l$tokens_bought
  l$i1$input_reserve := ($struct_get($struct_loc(self, 8)): Int)
  l$i1$output_reserve := l$token_reserve
  if (!(l$i1$input_reserve > 0 && $unwrap(l$i1$output_reserve) > 0)) {
    goto revert
  }
  if (l$i1$input_reserve * $unwrap(l$i1$output_amount) < 0) {
    goto revert
  }
  if (l$i1$input_reserve * $unwrap(l$i1$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i1$input_reserve * $unwrap(l$i1$output_amount))) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i1$input_reserve * $unwrap(l$i1$output_amount))) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$numerator := $wrap($unwrap($wrap(l$i1$input_reserve * $unwrap(l$i1$output_amount))) * 1000)
  if ($unwrap(l$i1$output_reserve) - $unwrap(l$i1$output_amount) < 0) {
    goto revert
  }
  if ($unwrap(l$i1$output_reserve) - $unwrap(l$i1$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i1$output_reserve) - $unwrap(l$i1$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap($unwrap(l$i1$output_reserve) - $unwrap(l$i1$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$denominator := $wrap($unwrap($wrap($unwrap(l$i1$output_reserve) - $unwrap(l$i1$output_amount))) * 997)
  if ($unwrap(l$i1$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i1$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1))
  goto i1$return
  label i1$return
  l$eth_sold := $wrap(i1$$res)
  if ($unwrap(l$eth_sold) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$eth_sold) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  $res := $unwrap($wrap($unwrap(l$eth_sold) * 1))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$getTokenToEthInputPrice(l$tokens_sold: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$i1$input_amount: $Int
  var l$i1$input_reserve: $Int
  var l$i1$output_reserve: Int
  var i1$$res: Int
  var l$i1$input_amount_with_fee: $Int
  var l$i1$numerator: $Int
  var l$i1$denominator: $Int
  var l$eth_bought: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$tokens_sold) && $unwrap(l$tokens_sold) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!($unwrap(l$tokens_sold) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$token_reserve := $wrap(l$raw_ret)
  // Inlined call of getInputPrice
  l$i1$input_amount := l$tokens_sold
  l$i1$input_reserve := l$token_reserve
  l$i1$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i1$input_reserve) > 0 && l$i1$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap(l$i1$input_amount) * 997 < 0) {
    goto revert
  }
  if ($unwrap(l$i1$input_amount) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$input_amount_with_fee := $wrap($unwrap(l$i1$input_amount) * 997)
  if ($unwrap(l$i1$input_amount_with_fee) * l$i1$output_reserve < 0) {
    goto revert
  }
  if ($unwrap(l$i1$input_amount_with_fee) * l$i1$output_reserve > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$numerator := $wrap($unwrap(l$i1$input_amount_with_fee) * l$i1$output_reserve)
  if ($unwrap(l$i1$input_reserve) * 1000 < 0) {
    goto revert
  }
  if ($unwrap(l$i1$input_reserve) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap(l$i1$input_reserve) * 1000 + $unwrap(l$i1$input_amount_with_fee) < 0) {
    goto revert
  }
  if ($unwrap(l$i1$input_reserve) * 1000 + $unwrap(l$i1$input_amount_with_fee) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$denominator := $wrap($unwrap(l$i1$input_reserve) * 1000 + $unwrap(l$i1$input_amount_with_fee))
  if ($unwrap(l$i1$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i1$$res := $unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator)))
  goto i1$return
  label i1$return
  l$eth_bought := $wrap(i1$$res)
  if ($unwrap(l$eth_bought) * 1 < 0) {
    goto revert
  }
  if ($unwrap(l$eth_bought) * 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  $res := $unwrap($wrap($unwrap(l$eth_bought) * 1))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$getTokenToEthOutputPrice(l$eth_bought: $Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var l$send_fail: Bool
  var l$raw_ret: Int
  var l$token_reserve: $Int
  var l$i1$output_amount: $Int
  var l$i1$input_reserve: $Int
  var l$i1$output_reserve: Int
  var i1$$res: Int
  var l$i1$numerator: $Int
  var l$i1$denominator: $Int
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= $unwrap(l$eth_bought) && $unwrap(l$eth_bought) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if (!($unwrap(l$eth_bought) > 0)) {
    goto revert
  }
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$TokenPurchase($arg0, $arg1, $arg2) } perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$EthPurchase($arg0, $arg1, $arg2) } perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==> acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$AddLiquidity($arg0, $arg1, $arg2) } perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$RemoveLiquidity($arg0, $arg1, $arg2) } perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==> acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Transfer($arg0, $arg1, $arg2) } perm(e$Transfer($arg0, $arg1, $arg2)) > none ==> acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
  exhale true && (forall $arg0: Int, $arg1: Int, $arg2: Int :: { e$Approval($arg0, $arg1, $arg2) } perm(e$Approval($arg0, $arg1, $arg2)) > none ==> acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
  inhale 0 <= l$raw_ret && l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  if (l$send_fail) {
    inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
    goto revert
  }
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  l$token_reserve := $wrap(l$raw_ret)
  // Inlined call of getOutputPrice
  l$i1$output_amount := l$eth_bought
  l$i1$input_reserve := l$token_reserve
  l$i1$output_reserve := ($struct_get($struct_loc(self, 8)): Int)
  if (!($unwrap(l$i1$input_reserve) > 0 && l$i1$output_reserve > 0)) {
    goto revert
  }
  if ($unwrap($w_mul(l$i1$input_reserve, l$i1$output_amount)) < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i1$input_reserve, l$i1$output_amount)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($w_mul(l$i1$input_reserve, l$i1$output_amount)) * 1000 < 0) {
    goto revert
  }
  if ($unwrap($w_mul(l$i1$input_reserve, l$i1$output_amount)) * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$numerator := $wrap($unwrap($w_mul(l$i1$input_reserve, l$i1$output_amount)) * 1000)
  if (l$i1$output_reserve - $unwrap(l$i1$output_amount) < 0) {
    goto revert
  }
  if (l$i1$output_reserve - $unwrap(l$i1$output_amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap($wrap(l$i1$output_reserve - $unwrap(l$i1$output_amount))) * 997 < 0) {
    goto revert
  }
  if ($unwrap($wrap(l$i1$output_reserve - $unwrap(l$i1$output_amount))) * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  l$i1$denominator := $wrap($unwrap($wrap(l$i1$output_reserve - $unwrap(l$i1$output_amount))) * 997)
  if ($unwrap(l$i1$denominator) == 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1 < 0) {
    goto revert
  }
  if ($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  i1$$res := $unwrap($wrap($unwrap((0 == $unwrap(l$i1$denominator) ? $wrap($unwrap(l$i1$numerator) / $unwrap(l$i1$denominator)) : $w_div(l$i1$numerator, l$i1$denominator))) + 1))
  goto i1$return
  label i1$return
  $res := $unwrap($wrap(i1$$res))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$tokenAddress() returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  $res := ($struct_get($struct_loc(self, 6)): Int)
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$factoryAddress() returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  $res := ($struct_get($struct_loc(self, 7)): Int)
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$balanceOf(l$_owner: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$_owner && l$_owner <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  $res := $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_owner): Int)))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$transfer(l$_to: Int, l$_value: $Int) returns ($succ: Bool, $res: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Bool
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$_to && l$_to <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= $unwrap(l$_value) && $unwrap(l$_value) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value)): $Map[Int, Int])): $Struct)
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to, $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value)): $Map[Int, Int])): $Struct)
  // Event: Transfer
  inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), l$_to, $unwrap(l$_value)), write)
  $res := true
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$transferFrom(l$_from: Int, l$_to: Int, l$_value: $Int) returns ($succ: Bool, $res: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Bool
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$_from && l$_from <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$_to && l$_to <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= $unwrap(l$_value) && $unwrap(l$_value) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_from): Int))) - $unwrap(l$_value) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_from): Int))) - $unwrap(l$_value) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_from, $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_from): Int))) - $unwrap(l$_value)): $Map[Int, Int])): $Struct)
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to, $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), l$_to): Int))) + $unwrap(l$_value)): $Map[Int, Int])): $Struct)
  if ($unwrap($wrap(($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_from): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value) < 0) {
    goto revert
  }
  if ($unwrap($wrap(($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_from): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) {
    $overflow := true
    goto revert
  }
  self := ($struct_set(self, 5, ($map_set(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_from, ($map_set(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_from): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_from): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$_value)): $Map[Int, Int])): $Map[Int, $Map[Int, Int]])): $Struct)
  // Event: Transfer
  inhale acc(e$Transfer(l$_from, l$_to, $unwrap(l$_value)), write)
  $res := true
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$approve(l$_spender: Int, l$_value: $Int) returns ($succ: Bool, $res: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Bool
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$_spender && l$_spender <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= $unwrap(l$_value) && $unwrap(l$_value) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  self := ($struct_set(self, 5, ($map_set(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), ($struct_get($struct_loc(msg, 0)): Int), ($map_set(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), ($struct_get($struct_loc(msg, 0)): Int)): $Map[Int, Int]), l$_spender, $unwrap(l$_value)): $Map[Int, Int])): $Map[Int, $Map[Int, Int]])): $Struct)
  // Event: Approval
  inhale acc(e$Approval(($struct_get($struct_loc(msg, 0)): Int), l$_spender, $unwrap(l$_value)), write)
  $res := true
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$allowance(l$_owner: Int, l$_spender: Int) returns ($succ: Bool, $res: Int)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $out_of_gas: Bool
  var l$havoc: Int
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for arguments
  inhale 0 <= l$_owner && l$_owner <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= l$_spender && l$_spender <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Assume invariants for self
  inhale (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  // Function body
  $res := $unwrap($wrap(($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), l$_owner): $Map[Int, Int]), l$_spender): Int)))
  goto return
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  $res := l$havoc
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
}

method f$__init__() returns ($succ: Bool)
{
  var msg: $Struct
  var block: $Struct
  var chain: $Struct
  var tx: $Struct
  var self: $Struct
  var $contracts: $Map[Int, $Struct]
  var $old_self: $Struct
  var $old_$contracts: $Map[Int, $Struct]
  var $pre_self: $Struct
  var $pre_$contracts: $Map[Int, $Struct]
  var $issued_self: $Struct
  var $issued_$contracts: $Map[Int, $Struct]
  var $overflow: Bool
  var $first_public_state: Bool
  var l$havoc: Int
  var $out_of_gas: Bool
  var l$havoc$1: Int
  var l$havoc$2: $Map[Int, $Struct]
  // Present state assumptions
  inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
  inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) && ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) && ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
  inhale (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
  inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) && ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) && ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) && ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int) && ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
  inhale (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
  inhale ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
  // Assume type assumptions for self address
  inhale 0 <= $self_address() && $self_address() <= 1461501637330902918203684832716283019655932542975
  // Assume type assumptions for block
  inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) && ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) && ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) && ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
  inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) && ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
  // Assume type assumptions for msg
  inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) && ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
  inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) && ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) && ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
  inhale ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
  inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
  // Copy state
  $pre_self := self
  $pre_$contracts := $contracts
  // Copy state
  $old_self := self
  $old_$contracts := $contracts
  $succ := true
  $overflow := false
  $first_public_state := true
  self := s$struct$self$init(($array_init(0, 32): Seq[Int]), ($array_init(0, 32): Seq[Int]), 0, 0, ($map_init(0): $Map[Int, Int]), ($map_init(($map_init(0): $Map[Int, Int])): $Map[Int, $Map[Int, Int]]), 0, 0, 0, 0, false, ($map_init(0): $Map[Int, Int]), ($map_init(0): $Map[Int, Int]), false)
  inhale l$havoc >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
  // Function is not payable
  inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
  label return
  if ($out_of_gas) {
    goto revert
  }
  goto end
  label revert
  $succ := false
  // Copy state
  self := $pre_self
  $contracts := $pre_$contracts
  // Copy state
  $old_self := $pre_self
  $old_$contracts := $pre_$contracts
  label end
  if ($first_public_state) {
    $old_self := self
  }
  // Assert checks
  if ($succ) {
    
  }
  inhale l$havoc$1 >= 0
  self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
  // Havoc state
  $contracts := l$havoc$2
  if ($first_public_state) {
    $old_self := self
  }
}