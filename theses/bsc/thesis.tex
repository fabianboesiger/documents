% !TEX program = xelatex
% !BIB program = biber

\documentclass[11pt]{article}

\usepackage{biblatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{graphicx}

\setmonofont[
  Contextuals={Alternate},
  Scale=0.8
]{Fira Code}

\addbibresource{viper.bib}
\addbibresource{silicon.bib}
\addbibresource{patterns.bib}
\addbibresource{intellij.bib}

\parskip=1em
\parindent=0pt

\definecolor{codegrey}{rgb}{0.95,0.95,0.95}
\definecolor{commentgrey}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily,
    keywordstyle=\bfseries,
    commentstyle=\color{commentgrey},
    backgroundcolor=\color{codegrey},
    frame=single,
    numbers=left,
}
\lstset{style=mystyle}

\begin{document}

    \pagenumbering{gobble}
    \begin{titlepage}
        \begin{center}
            \textbf{\huge Flyweight ASTs:\\A Study in Applied Lazyness}\\
            \vspace{0.2cm}
            \textit{Bachelor's Thesis}\\
            \vspace{1cm}
            \includegraphics[width=0.5\textwidth]{fly}
            \vfill   
            Fabian Bösiger\\
            Supervised by Dr. Malte Schwerhoff\\
            \vspace{0.2cm}
            Programming Methodology Group\\
            Department of Computer Science\\
            ETH Zürich\\
            \vspace{0.2cm}
            \today
        \end{center}
    \end{titlepage}
    \newpage

    \begin{abstract}
        \parskip=1em
        \parindent=0pt
        \noindent

        
    \end{abstract}
    \newpage

    \renewcommand{\abstractname}{Acknowledgements}
    \begin{abstract}
        \parskip=1em
        \parindent=0pt
        \noindent

        I would like to thank my supervisor, Malte Schwerhoff, who provided
        me with the opportunity to write this thesis. I am very grateful for the time
        and effort he expended.

        I would also like to thank Peter Müller for leading the Programming Methodology
        Group, which always appears in an open and welcoming way. 

        Finally, I'd like to express my gratitude towards my family for providing
        me with a very pleasant home office environment.
    \end{abstract}
    \newpage

    \tableofcontents
    \newpage

    \pagenumbering{arabic}

    \section{Introduction}
    
    \subsection{Implementation of Flyweight ASTs} \label{approach:flyweight}

    Abstract syntax trees (AST) are used in compilers and similar programs to represent
    the structure of a program as a tree data structure. As with any other tree structure,
    ASTs can be traversed, searched, transformed and so forth. During such operations,
    subtrees within the AST are potentially checked for equality many times.  Moreover, equality checks
    also occur in operations on collections of AST subtrees, for example in finding
    a specific subtree, which may add additional performance overhead.

    Equality checks can't be avoided, but they can be implemented in a more performant way.
    Currently in Silicon, new term instances are created independently of already existing ones, which potentially leads 
    to the coexistence of multiple structurally equal term instances. Subterm equality is checked in a
    structural and recursive manner.

\begin{lstlisting}[language=Scala, caption={Simplification of how term instances currently are
    implemented. Because \texttt{Plus} is defined as a case class, the compiler automatically
    generates code for recursive structural equality checking.}]
case class Plus(val p0: Term, val p1: Term) extends Term
\end{lstlisting}
        
    Because the AST used in Silicon is immutable, the flyweight pattern \cite{patterns}
    can be applied on AST terms.
    To do this, pool of term instances is maintained. Whenever a term
    is to be created, the components of this new term is compared with the
    pool of existing terms. If a term with the same components already exists, it is returned and
    the creation of a new instance of this term is avoided. Otherwise, a new term is created and added to
    the pool.

    This gives the guarantee that there are no two instances of the
    same term in our pool, meaning every two structurally equal terms point to the same
    underlying object in memory. Comparing terms for structural equality then boils
    down to a cheap reference equality check, and recursive equality checks can be avoided.
    
    \begin{lstlisting}[language=Scala, caption=Avoid instantiating multiple structurally equal terms using the flyweight pattern.]
class Plus private (left: Term, right: Term) extends Term {
    // ...
}

object Plus extends ((Term, Term) => Plus) {
    // Pool object which holds our "Plus" terms.
    var pool = new HashMap[(Term, Term), Plus]

    def apply(e0: Term, e1: Term) = {
        pool.get((e0, e1)) match {
            // If this term already exists in pool, return it. 
            case Some(term) => term
            // Otherwise, create a new instance.
            case None =>
                val term = new Plus(e0, e1)
                pool.addOne((e0, e1), term)
                term
        }
    }

    // ...
}
    \end{lstlisting}

    The \texttt{Plus} constructor is now private, which makes it impossible to
    create \texttt{Plus} instances without checking the pool first. The companion
    object \texttt{Plus} now contains a pool of all existing \texttt{Plus} instances. Furthermore,
    \texttt{Plus} is no longer a case class, which means that the default \texttt{equals}
    method no longer recursively checks for structural equality, but instead
    simply does a reference equality check. Because Scala's equality operator (\texttt{==})
    and data structures such as \texttt{HashMap} use the \texttt{equals} method behind
    the scenes, this will most likely lead to performance improvements.

    \subsection{Automate Boilerplate Generation using Macros} \label{approach:macros}

    Silicon's AST representation of the Viper language consists of nearly 100 different terms,
    all with boilerplate implementations for different operations.
    Our changes introduce additional boilerplate code to each term companion object, as seen in the case
    of the \texttt{Plus} term in listing 2.

    Our ASTs shouldn't only be flyweight in the sense of the implementation pattern, but also
    regarding development time and effort. This is why we want to avoid such boilerplate
    code and instead automatically generate companion objects seen in listing 2 using Scala's macro annotations.
    Additional benefits of using macro annotations include improvements in code
    readability and maintainability. Experimenting with code changes will become a matter
    of editing a single macro instead of editing each term individually.
    Terms which may be added in the future are easier to implement.

    \section{Implementation}

    \subsection{A Macro Annotation for Code Generation}

    \subsection{Classes or Case Classes}

    \subsection{Macro Annotations on Nodes}

    \subsection{}

    \section{Evaluation}

    \subsection{Verification Time}

    The flyweight pattern can be applied effectively if two main points hold.
    First, the application uses large numbers of objects and causes high storage costs. \cite{patterns}
    This is true for ASTs as they can grow large containing a large amount of objects.
    
    Second, groups of objects may be replaced by few shared objects once extrinsic state is removed. \cite{patterns}
    In ASTs, many nodes have no state at all, such as \texttt{True}, \texttt{False}.
    They are well suited as flyweight objects. For non-leave nodes, extrinsic state
    cannot be externalized, for example the children of a \texttt{Plus(t1, t2)} node.

    \end{enumerate}

    \subsection{Memory Consumption}

    \subsection{Automatic Code Generation}

    \printbibliography
    
\end{document}