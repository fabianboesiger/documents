% !TEX program = xelatex
% !BIB program = biber

\documentclass[11pt]{article}

\usepackage{biblatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{graphicx}

\setmonofont[
  Contextuals={Alternate},
  Scale=0.8
]{Fira Code}

\addbibresource{viper.bib}
\addbibresource{silicon.bib}
\addbibresource{patterns.bib}
\addbibresource{intellij.bib}

\parskip=1em
\parindent=0pt

\definecolor{codegrey}{rgb}{0.95,0.95,0.95}
\definecolor{commentgrey}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily,
    keywordstyle=\bfseries,
    commentstyle=\color{commentgrey},
    backgroundcolor=\color{codegrey},
    frame=single,
    numbers=left,
}
\lstset{style=mystyle}

\begin{document}

    \pagenumbering{gobble}
    \begin{titlepage}
        \begin{center}
            \textbf{\huge Flyweight ASTs:\\A Study in Applied Lazyness}\\
            \vspace{0.2cm}
            \textit{Bachelor's Thesis}\\
            \vspace{1cm}
            \includegraphics[width=0.5\textwidth]{fly}
            \vfill   
            Fabian Bösiger\\
            Supervised by Dr. Malte Schwerhoff\\
            \vspace{0.2cm}
            Programming Methodology Group\\
            Department of Computer Science\\
            ETH Zürich\\
            \vspace{0.2cm}
            \today
        \end{center}
    \end{titlepage}
    \newpage

    \begin{abstract}
        \parskip=1em
        \parindent=0pt
        \noindent

        
    \end{abstract}
    \newpage

    \renewcommand{\abstractname}{Acknowledgements}
    \begin{abstract}
        \parskip=1em
        \parindent=0pt
        \noindent

        I would like to thank my supervisor, Malte Schwerhoff, who provided
        me with the opportunity to write this thesis. I am very grateful for the time
        and effort he expended.

        I would also like to thank Peter Müller for leading the Programming Methodology
        Group, which always appears in an open and welcoming way. 

        Finally, I'd like to express my gratitude towards my family for providing
        me with a very pleasant home office environment.
    \end{abstract}
    \newpage

    \tableofcontents
    \newpage

    \pagenumbering{arabic}

    \newpage
    \section{Approach}

    \subsection{Implementation of Flyweight ASTs} \label{approach:flyweight}

    Abstract syntax trees (AST) are used in compilers and similar programs to represent
    the structure of a program as a tree data structure. As with any other tree structure,
    ASTs can be traversed, searched, transformed and so forth. During such operations,
    subtrees within the AST are potentially checked for equality many times.  Moreover, equality checks
    also occur in operations on collections of AST subtrees, for example in finding
    a specific subtree, which may add additional performance overhead.

    Equality checks can't easily be avoided, but they can be implemented in a more performant way.
    Currently in Silicon, new term instances are created independently of already existing ones, which potentially leads 
    to the coexistence of multiple structurally equal term instances. Subterm equality is checked in a
    structural and recursive manner.

    Because the AST used in Silicon is immutable, the flyweight pattern \cite{patterns}
    can be applied on AST terms.
    To do this, pool of term instances is maintained. Whenever a term
    is to be created, the components of this new term is compared with the
    pool of existing terms. If a term with the same components already exists, it is returned and
    the creation of a new instance of this term is avoided. Otherwise, a new term is created and added to
    the pool.

    This gives the guarantee that there are no two instances of the
    same term in our pool, meaning every two structurally equal terms point to the same
    underlying object in memory. Comparing terms for structural equality then boils
    down to a cheap reference equality check, and recursive equality checks can be avoided.

    \subsection{Automate Boilerplate Generation using Macros} \label{approach:macros}

    Silicon's AST representation of the Viper language consists of nearly 100 different terms,
    all with boilerplate implementations for different operations.
    Our changes introduce additional boilerplate code to each term.

    Our ASTs shouldn't only be flyweight in the sense of the implementation pattern, but also
    regarding development time and effort. This is why we want to avoid such boilerplate
    code and instead automatically generate companion objects seen in listing 2 using Scala's macro annotations.
    Additional benefits of using macro annotations include improvements in code
    readability and maintainability. Experimenting with code changes will become a matter
    of editing a single macro instead of editing each term individually.
    Terms which may be added in the future are easier to implement.

    \newpage
    \section{Implementation}

    \subsection{A Macro Annotation for Code Generation}

    \begin{enumerate}
        \item If an \texttt{apply} method is already defined, rename it to \texttt{\_apply}.
            The already defined apply method can't be discarded because it potentially
            performs AST simplifications.
        \item Define a new \texttt{apply} method which uses the flyweight pattern.
            If a new instance has to be created, either use \texttt{\_apply} method
            if it exists, else simply create an instance using the \texttt{new} keyword.
        \item Generate an \texttt{unapply} method.
        \item Generate a \texttt{copy} method that calls \texttt{apply} instead of creating
            instances via \texttt{new} such that the flyweight pattern can't be bypassed.
        \item Override \texttt{hashCode} to use \texttt{System.identityHashCode}.
    \end{enumerate}

    The inner workings of our macro annotation is best shown in an example.

    \begin{lstlisting}[language=Scala, caption=Input code given to the macro.]
@flyweight
class Plus(val p0: Term, val p1: Term)
    extends ArithmeticTerm with BinaryOp[Term]
{
    override val op = "+"
}

object Plus extends ((Term, Term) => Term) {
    import predef.Zero

    def apply(e0: Term, e1: Term): Term = (e0, e1) match {
        case (t0, Zero) => t0
        case (Zero, t1) => t1
        case (IntLiteral(n0), IntLiteral(n1)) => IntLiteral(n0 + n1)
        case _ => new Plus(e0, e1)
    }
}        
    \end{lstlisting}

    \begin{lstlisting}[language=Scala, caption=Output code generated by our macro.]
class Plus private[terms] (val p0: Term, val p1: Term)
    extends ArithmeticTerm with BinaryOp[Term]
{
    override lazy val hashCode = System.identityHashCode(this)

    def copy(p0: Term = p0, p1: Term = p1) = Plus(p0, p1)

    override val op = "+"
}

object Plus extends ((Term, Term) => Term) {
    import scala.collection.concurrent.TrieMap
    var pool = new TrieMap[(Term, Term), $returnType]

    def apply(e0: Term, e1: Term): Term = {
        pool.get((e0, e1)) match {
            case None => 
                val term = Plus._apply(e0, e1)
                pool.addOne((e0, e1), term)
                term
            case Some(term) => 
                term
        }
    }

    def unapply(t: Plus) =
        Some((t.p0, t.p1))

    import predef.Zero

    def _apply(e0: Term, e1: Term): Term = (e0, e1) match {
        case (t0, Zero) => t0
        case (Zero, t1) => t1
        case (IntLiteral(n0), IntLiteral(n1)) => IntLiteral(n0 + n1)
        case _ => new Plus(e0, e1)
    }
}       
    \end{lstlisting}

    \subsection{Classes or Case Classes}

    \subsection{Macro Annotations on Nodes}

    \subsection{Clear Pools after each File}

    \subsection{AST Reduction for Builtin Equals}

    \subsection{Equality Defining Members}

    \newpage
    \section{Evaluation}

    \subsection{Concluding Performance Evaluation}

    To measure the performance difference, test cases over a wide variety of Viper
    frontends are considered.

    \begin{center}
        \begin{tabular}{ |l|c|c| } 
        \hline
        Resources Used & VerCors, Prusti, Gobra, Vyper \\ 
        \hline
        Number of Parallel Verifiers & 1 \\
        \hline
        Repetitions & 10 \\ 
        \hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{ |l|c|c| } 
        \hline
        Implementation & Relative Performance Change & Standard Derivation \\ 
        & (Negative is better) & \\
        \hline
        Flyweight Pattern & 2\% & 2.9\% \\ 
        \hline
        \end{tabular}
    \end{center}

    Unfortunately, a performance improvement is not observable.
    The performance difference is well within the standard derivation.

    \subsection{Performance of Different Data Structures for the Memory Pool}

    \begin{center}
        \begin{tabular}{ |l|c|c| } 
        \hline
        Resources Used & VerCors \\ 
        \hline
        Number of Parallel Verifiers & 1 \\
        \hline
        Repetitions & 10 \\ 
        \hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{ |l|c|c| } 
        \hline
        Data Structure & Relative Performance Change & Standard Derivation \\ 
        & (Negative is better) & \\
        \hline
        \texttt{mutable.HashMap} & -1.3\% & cell3 \\ 
        \texttt{mutable.WeakHashMap} & -0.2\% & cell6 \\
        \texttt{concurrent.TrieMap} & -0.2\% & cell9 \\
        \texttt{concurrent.ListMap} & +89.5\% & cell9 \\ 
        \hline
        \end{tabular}
    \end{center}

    As expected, the use of \texttt{ListMap} significantly worsens performance.
    The performance of \texttt{HashMap}, \texttt{WeakHashMap}, \texttt{TrieMap}
    are very similar considering the standard derivation. \texttt{TrieMap} however
    has the additional benefit of being concurrency-safe.

    \subsection{Memory Consumption}

    \subsection{Memory Pool Hit Rate}

    \subsection{AST Node Count on Equality Checks}

    \subsection{Why did Flyweight Fail}

    \subsection{Automatic Code Generation}

    \subsection{Impact of AST Simplifications on Performance}

    Thanks tho the macro annotation, Silicon can easily be edited to ignore
    AST simplifications. To achieve this, calling \texttt{\_apply}, which performs AST
    simplifications, is avoided. Instead, we directly create instances using \texttt{new}.

    \begin{lstlisting}[language=Scala, caption=Use AST simplifications.]
def apply(..$fields) = {
    // ...
    ${
        if (hasRenamedApplyMethod)
            q"${termName}._apply(..${fieldNames})"
        else
            q"new $className(..${fieldNames})"
    }
    // ...
}  
    \end{lstlisting}

    \begin{lstlisting}[language=Scala, caption=Ignore AST simplifications.]
def apply(..$fields) = {
    // ...
    ${
        q"new $className(..${fieldNames})"
    }
    // ...
}  
    \end{lstlisting}

    Although the flyweight pattern itself didn't have a significant impact on performance,
    the macro annotation developed to implement the flyweight pattern can
    be quickly modified to perform experiments or benchmarks on the Silicon AST.

    \printbibliography
    
\end{document}